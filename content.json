[{"title":"发送数据到其他应用-关于知乎的分享是如何实现","slug":null,"date":"2017-04-17T08:25:00.000Z","updated":null,"comments":null,"path":"2017/04/17/2017041716_发送消息到其他应用/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"在使用知乎的过程中一直对知乎的分享功能非常的在意，知乎的分享好似使用的Intent发送数据，调用的Android系统的分享界面，但是却又可以调用微信发送webpage，达到和使用微信分享SDK一模一样的功能，以下为知乎分享截图 翻了翻Android文档发现，通过Intent进行分享需要设置ACTION_SEND或者ACTION_SEND_MULTIPLE ACTION_SEND使用此Action可以发送单个的文本数据或者二进制数据(如图片) 一.发送文本消息12345Intent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, \"This is my text to send.\");sendIntent.setType(\"text/plain\");startActivity(sendIntent); 你可以通过调用 Intent.createChooser() 来发送Intent，这样做将会始终显示选择器。这有一定的优势: 即使用户先前已经选择了这个意图的默认操作，仍然会显示选择器 如果没有应用程序匹配，将会显示系统提示 您可以指定选择器对话框的标题 下面是更新后的代码 12345Intent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, \"This is my text to send.\");sendIntent.setType(\"text/plain\");startActivity(Intent.createChooser(sendIntent, getResources().getText(R.string.send_to))); 二.发送二进制消息12345Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND);shareIntent.putExtra(Intent.EXTRA_STREAM, uriToImage);shareIntent.setType(\"image/jpeg\");startActivity(Intent.createChooser(shareIntent, getResources().getText(R.string.send_to))); 这里的Uri推荐使用一下两种方式获取 将数据存储在自己的ContentProvider，并确保其他应用程序有访问的正确权限，其次也可以临时的并且授予访问权限给接受应用程序。 使用系统的MediaStore。MediaStore主要针对视频，音频和图像MIME类型，需要ANdroid3.0（API 11）之后。一旦添加到系统MediaStore的内容是设备上的任何应用程序都能访问的 ACTION_SEND_MULTIPLE如果要分享多个内容，使用ACTION_SEND_MULTIPLE设置带有指向内容的URI列表即可实现，MIME类型根据您共享的结构变化，例如，如果您分享3个JPEG图像，类型仍然是”image/jpeg”。对于图像类型的混合结构,应该使用”image/*“，如果您分享了多种多样的类型。您应该使用 “*/*“ 123456789ArrayList&lt;Uri&gt; imageUris = new ArrayList&lt;Uri&gt;();imageUris.add(imageUri1); // Add your image URIs hereimageUris.add(imageUri2);Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);shareIntent.setType(\"image/*\");startActivity(Intent.createChooser(shareIntent, \"Share images to..\")); 知乎的分享实现系统的分享功能大概就是如上所述，我们发现这里面并没有发送webpage的功能，更别说实现和微信SDK分享一模一样的效果。我能想到的还是自定义分享对话框了。通过如下代码可以获取到能接受到指定MIME类型的应用 1234567Intent sharingIntent = new Intent(android.content.Intent.ACTION_SEND);// what type of data needs to be send by sharingsharingIntent.setType(\"text/plain\");// package namesPackageManager pm = getPackageManager();// list packageList&lt;ResolveInfo&gt; activityList = pm.queryIntentActivities(sharingIntent, 0); 以上只是个人的猜想，不过从下面几个方面也能验证我的这个想法，首页我创建了一个应用指定接收了”text/plain”类型的消息，发现知乎发送给我这个应用的消息为: 和家里人吃饭口味相差很大是一种什么样的体验？ http://www.zhihu.com/question/58485685?utm_source=qq&amp;utm_medium=social （分享自知乎网） 发送给微博的消息为: 和家里人吃饭口味相差很大是一种什么样的体验？ - 677个回答，2404人关注，http://zhihu.com/question/58485685?utm_source=weibo&amp;utm_medium=social（想看更多？下载 @知乎 App：http://weibo.com/p/100404711598） 而发送给微信的又是和微信SDK分享一样的webpage格式，说明知乎给应用发送的消息是在点击后设置的，而根据我google的结果来看，android暂时还不支持监听点击事件的功能， 之后我打开开发者工具中的显示布局边界功能观察知乎分享对话框和系统对话框的不同， 知乎分享对话框: 系统分享对话框: 可以发现两者的布局还是有着明显的不同的，所以最后的结论是: 知乎分享的实现方式为，获取可以接受自己要分享的消息类型的应用，自定义对话框且样式和系统分享对话框相差无几，之后再用户点击要分享的应用时，设置不同的消息类型，或是改变文字、或是调用微信分享SDK，达到自己想要的效果","raw":null,"content":null,"categories":null,"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Android Handler 探索","slug":null,"date":"2016-04-27T08:30:00.000Z","updated":null,"comments":null,"path":"2016/04/27/2016042710_Handler详解/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"众所周知在 UI 线程中不能执行耗时操作，否则 UI 线程将会堵塞造成应用卡顿甚至异常报错，因此我们往往会将耗时操作放在工作线程中，但是这些任务往往需要更新 UI 组件的状态，但是对 UI 组件的操作只能在 UI 线程中执行，Android 为了处理这个问题，提供了一个消息传递机制 Handler 一、消息传递机制中的分工在这个消息传递机制中 Handler 和 Message 是我们平时接触最多的，而在这幕后还有 MessageQueue 和 Looper 默默的工作着，接下来让我们跳开细节来看看它们这这个机制中都担任什么样的角色 Handler在平常的使用中我们经常会在工作线程中调用 Handler 的 sendMessage() 方法发送一个 Message 对象，然后 Handler 的 handleMessage() 方法会被回调到并且可以拿到使用 sendMessage() 发送的 Message 对象，并且 handleMessage() 方法是在 UI 线程中被执行的，这也是我们经常使用的方法但是在这背后到底发送了什么，我们大多数人并不了解。 MessageMessage 是容纳任意数据的容器。Message 就像一封信一样，上面记载了内容、时间、寄到哪里等等信息。 what – 标识符，Handler 能够根据它区分不同的消息来源，采取不同的处理方式 when – 发送出去的时间，如果调用的不是 sendMessageDelayed() 方法那么 when 将等于 SystemClock.uptimeMillis() ，这个方法将会返回当前时间。 target – 表示由哪个 Handler 处理这个 Message ，也就是将 Message 发送出去的那个 Handler 。 至于其他的 obj、arg1、arg2 等参数就是用来存储数据的容器这里就不在赘述了。 MessageQueueMessageQueue 是一个消息体对象的 LinkedList 集合。它按照时序（Message.when）将消息插入队列，最小的时间戳将会被首先处理，消息队列将会通过 SystemClock.uptimeMillis() 获取当前时间，当一个 Message 的时间戳(Message.when) 低于这个值的时候，消息就会分发给 Handler 处理。 LooperLooper 从消息队列中读取消息，然后分发给对应的 Handler 处理。一旦消息的时间戳低于当前时间，那么 Looper就会在下一轮读取过程中读取到它。Looper 在没有消息分发的时候会变为堵塞状态，当有消息可用时将会继续轮询 二、Message的神奇冒险在上面的篇章中我们叙述了消息处理机制中每个角色所承担的责任，接下来让我们来了解下消息处理机制是怎么运行的。 首先我们应该知道的是为什么 Message 在工作线程中发出，却能在 UI 线程中被处理呢？那必定是因为负责消息分发的 Looper 是在 UI 线程中进行的对消息的处理，当 Handler 调用 sendMessage() 等类似方法时，Message 仅仅是在被加入到 MessageQueue 队列中，并没有和 Looper 有任何实际的接触，而在另外一边处于 UI 线程的 Looper 一直处于堵塞状态等待着 MessageQueue 队列有新的 Message 被加入，当 Looper 发现有 Message 加入时，将进入轮询状态，根据 Message 的发出时间在合适的时候将 Message 下发到对应的回调中进行处理， 如果上面这一段话看懂了那么对于消息处理机制也就明白了大半了，既然 Looper 是在 UI 线程中运行处理 Message 的那么我们可以知道的是 Looper 必定也是在 UI 线程中被创建的，我们先来看看 Handler 是怎么发送 Message 的，下面这两种对于 Handler 是我们最常用的方法。 第一次方法：使用 sendMessage()、sendMessageDelayed()、sendMessageAtTime() 等方法发送消息 12345678910111213141516171819// UI 线程中创建 HandlerHandler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //UI 线程中处理消息 &#125;&#125;; //工作线程中发出消息new Thread(new Runnable() &#123; @Override public void run() &#123; //耗时操作 //.... Message message = Message.obtain(); handler.sendMessage(message); &#125;&#125;).start(); 第二种方法：使用 post()、postDelayed()、postAtTime() 等方法发送消息 12345678910111213141516// UI 线程中创建 HandlerHandler handler = new Handler();new Thread(new Runnable() &#123; @Override public void run() &#123; //耗时操作 //.... handler.post(new Runnable() &#123; @Override public void run() &#123; // 在 UI 线程中被回调 &#125; &#125;); &#125;&#125;).start(); 上面两种方法其实并没有什么不同 Handler.post() 其实只是在 sendMessageDelayed() 上面加了一层封装，我们可以看下 Handler.post() 的代码 123456789public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 可以看到 Handler.post() 方法最后调用的还是 sendMessageDelayed() 方法，而 sendMessageDelayed() 又是调用的 sendMessageAtTime() 方法，其他的 postDelayed()、postAtTime() 方法想必都能猜到了最后也都是调用到 sendMessageAtTime() 方法。我们可以看下 sendMessageAtTime() 的代码 1234567891011121314151617public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 上面这一大段代码最重要的就是第 12 行和第 16 行了，我们之前说过 Message 的 target 字段表示由哪一个 Handler 来回调处理这个消息，而这里的 target = this 也就表示了将由调用了 sendMessageAtTime 方法的 Handler 来处理。之后在第 16 行将 Message 加入到 MessageQueue 队列中。 我们可以继续深入来看看 queue.enqueueMessage(msg, uptimeMillis) 到底做了什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 这个方法里主要做了两件事情，使用 msg.when 保存消息发出的时间，之后根据 when 对消息队列进行排序，同时我们也能看出来 MessageQueue 并没有用一个集合将所有的 Message 保存起来，它只是使用了一个 mMessage 对象表示当前需要处理的消息，而下一个需要处理的消息被保存在了 Message.next 中，从 20 - 45 行的代码中我们也能看到这个队列根据 when 被排序，每一个 Message 指定了下一个要被处理的 Message 由此组成了一个按照时间先后顺序等待被处理的 MessageQueue。 剩下的就是 Looper 了，Looper 可能是大家最陌生的一块了，Looper 什么时候被创建的，又是怎么运行着呢，我们可以看看 Handler 的构造方法来探寻 Looper 的轨迹 12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可以看到第 11-15 行对 Looper 对象做了一个非空判断，如果为空那么将会抛出异常，同时在第 17 行 Handler 从Looper拿到了一个 mQueue 这个 mQueue 就是 MessageQueue ，上面的sendMessage() 等方法最后就是将 Message 加入到这个 mQueue 中的。 我们可以继续进入到 Looper.myLooper() 方法中去看看 123456// sThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 我们可以看到 Looper 就保存在 sThreadLocal 这个静态的常量中，不过我们发现这个常量上面还有一段注释意思为：sThreadLocal.get() 将返回 null ，除非你调用了 prepare()，我们知道如果返回了 null 那么在 Handler 的构造方法中将会抛出异常，但是事实上在我们日常的使用过程中并没有遇到这个异常，那么就说明 prepare() 这个方法在我们所不知道的地方被调用过了，不过现在让我们暂时跳过这个细节，继续看 sThreadLocal.get() 里面到底做了什么 1234567891011121314public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 我们可以看到代码的第二行调用了 Thread.currentThread() 拿到当前线程对象，调用了 getMap() 获取到了 ThreadLocalMap 从 getMap 这个方法里我们可以看到 ThreadLocalMap 是保存在 Thread 对象里的一个属性，之后又经过一系列的调用从 ThreadLocalMap 中拿到了 Looper ，我们可以不用管 ThreadLocalMap 到底是什么不过从这个类的名字以及之后调用的代码我们可以大概猜到，Looper 存放在一个类似于 Map 的集合中，ThreadLocalMap 又保存在当前线程中，由此我们可以推断出 Looper 是和当前线程绑定在一起的，且依赖于当前线程的。 说了这么多那么 Looper.prepare() 到底是什么时候调用的呢？其实在程序被启动时，系统就已经帮我们调用了 Looper.prepare() 方法，这段代码就在 ActivityThread 的 main() 方法中 12345678910111213141516171819202122232425262728293031323334353637383940 public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 在第 21 行调用了 Looper.prepareMainLooper() 第 37 行调用了 Looper.loop() 这两行是和 Looper 有关的代码，我们先来看看 Looper.prepareMainLooper() 做了什么 12345678910111213141516public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 可以看到在 prepareMainLooper() 中调用了 prepare() 方法，在 prepare() 方法中又调用了 sThreadLocal.set(new Looper(quitAllowed)) 这段代码刚好对应了之前的 sThreadLocal.get() 代码，并且在调用 sThreadLocal.set() 之前首先调用了 sThreadLocal.get() 判断是否为 null，从 13 行的错误信息也可以看出来，每个线程只能创建一个 Looper，这也验证了我们上面的想法，Thread 只有一个 threadLocals 属性用于保存 Looper，所以就没必要再创建一个 Looper 了，当然这只是表面的原因，至于为什么只能有一个 Looper 就只有更加深入研究 Android 源码才能知道了，不过这个就不在本篇博文的范围了。 看完了 prepareMainLooper() 让我们接着往下看第 37 行的 Looper.loop() 又做了什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 我们可以从第 13 行看起在这里 Looper 构建了一个死循环，在没有消息进入时程序将会一直堵塞在第 14 行的 queue.next() 处，等待着新的 Message 被加入，当有消息被加入时，Looper 将被唤醒调用到第 32 行的代码进行下发，msg.target 大家应该还没有忘记是什么，就是调用了 sendMessage() 方法的 Handler 。我们可以继续看看 dispatchMessage 是怎么分发消息的 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; msg.callback 就是调用 Handler.post() 传入的 Runnable，mCallback 是 Handler 本事的回调参数，可以看到 mCallback 如果不为 null 那么将会被优先回调，并且根据放回值来觉得是否回调重构方法 handleMessage()。上面这个过程很简单大家应该不会被绕晕吧。 三、总结可能由于篇幅太长所以大家看的有点迷糊，在这里让我们再来总结下消息处理机制是怎么运作的。 首先如果你是在主线程中创建 Handler 那么无需调用 Looper.prepare() 创建 Looper 也无需调用 Looper.loop() 来让 Looper 运行起来，因为在程序启动时系统已经为我们在主线程中调用了这些代码。当然也不要忘了当 Looper 被创建时 Looper 内部会生成 MessageQueue 消息队列，当 Handler 实例化时会去 Looper 中获取 MessageQueue 的引用，以便将 Message 加入到消息队列中。 当 Handler 创建完成之后，我们就可以调用 sendMessage() 等方法了，这些方法最后会将 Message 添加到 MessageQueue 中，而 MessageQueue 在添加 Message 之前会根据 Message 的发送时间进行排序，越早被发送出去的就排在前面，同时会持有下一个将被发送的 Message 的引用，依次循环。 在另外一边，Looper 构建了一个死循环堵塞在 queue.next() 处等待着 Message 被加入，但是不能忘了，Looper 是依附于线程的，我们能在主线程中重新接收到 Message 是因为我们是在主线程中创建的 Handler 拿到到的是主线程 Looper 中的 MessageQueue 消息队列，所以我们才能在主线程中回调到，如果我们是在其他线程中创建的 Handler 那么就会在这个线程中接收到消息。 当 Looper 拿到 Message 后，将会调用 Message.target.dispatchMessage() 进行分发，Message.target 就是发送出 Message 的 Handler。dispatchMessage 被调用后会重新回到 post 里的 Runnable 或者是 handleMessage 方法等。 上面就是当一个 Message 被发出后，在到被重新接收到的一个完整过程，不过这里我们也会产生一个疑问。为什么主线程的 Looper 里面构建一个死循环后，主线程不会被堵塞呢，这个问题在知乎上也有一个提问，我们可以在这里面找到答案 Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ 本篇博文到此结束，感谢阅读。","raw":null,"content":null,"categories":null,"tags":[{"name":"Android 深入解析","slug":"Android-深入解析","permalink":"http://yoursite.com/tags/Android-深入解析/"}]},{"title":"在 Android Studio 中支持 Java 8","slug":null,"date":"2016-03-16T02:14:00.000Z","updated":null,"comments":null,"path":"2016/03/16/2016031610_在AndroidStudio中支持Java8/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"随着 Android N 开发者预览版的发布 Android 也终于支持 Java 8 了，终于可以开心的使用 Lambda 表达式了，怀着激动的心情马上将 Android studi 升级到 2.1，试着用 Lambda 表达式写了一个点击监听如下: Android Studio 提示我需要设置 Java 8 ,点击后发现在 build.gradle 下多了一段代码 1234compileOptions &#123; targetCompatibility 1.8 sourceCompatibility 1.8&#125; 看来这段就是支持 java 8 的设置了。点击运行后发现报错了 1234567编译器 (1.8.0_74) 中出现异常错误。如果在 Bug Database (http://bugs.java.com) 中没有找到该错误, 请通过 Java Bug 报告页 (http://bugreport.java.com) 建立该 Java 编译器 Bug。请在报告中附上您的程序和以下诊断信息。谢谢。com.sun.tools.javac.code.Symbol$CompletionFailure: 找不到java.lang.invoke.MethodType的类文件Error:Execution failed for task ':app:compileDebugJavaWithJavac'.&gt; Compilation failed; see the compiler error output for details. 以上就是错误信息，前往 Android 官方文档 查看后发现，想要支持 Java 8 需要使用 Jack 编译工具，Java 8 完整的配置如下 12345678910111213android &#123; ... defaultConfig &#123; ... jackOptions &#123; enabled true &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 并且还需要将 Android Studio 更新到 2.1 ，Android SDK 需要下载 Android N Preview ，JDK 当然也是需要更新到 8。 另外在官网上还发现这样一段话 Note: Using the new Java 8 language features is not a requirement for developing apps that target the Android N platform. If you don’t want to write code with Java 8 language features, you can keep your project’s source and target compatibility values set to Java 7, but you still must compile with JDK 8 to build against the Android N platform. 开发面向 Android N 平台的应用并不要求必须使用新的 Java 8 语言功能。如果您不想使用 Java 8 语言功能编写代码，您可以将项目的源和目标兼容性值保留为 Java 7，但您仍必须使用 JDK 8 进行编译，以便针对 Android N 平台进行构建。","raw":null,"content":null,"categories":null,"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://yoursite.com/tags/Android-Studio/"}]},{"title":"第三方控件 android floating action button 解析 (part2) - FloatingActionsMenu","slug":null,"date":"2016-03-09T07:55:00.000Z","updated":null,"comments":null,"path":"2016/03/09/2016030311_android_floating_action_button_part2/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"在上一篇我们对 FloatingActionButton 的代码进行了分析，在这一章我们将继续解析 FloatingActionMenu 的代码，FloatingActionMenu 是基于 FloatingActionButton 的实现，其子控件必须为 FloatingActionButton 才能达到相应的效果，在开始源码解析之前先让我们先来看看 FloatingActionMenu 要怎么使用吧。 FloatingActionMenu 的使用FloatingActionMenu 继承自 ViewGroup ，xml中的写法如下 123456789101112131415&lt;com.getbase.floatingactionbutton.FloatingActionsMenu android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/com.getbase.floatingactionbutton.FloatingActionsMenu&gt; 只要简单的包裹 FloatingActionButton 就可以达到下面的效果 如果想要在展开的按钮旁边显示文字标签的话，只需要为 FloatingActionMenu 设置 fab_labelStyle 属性，然后给子控件 FloatingActionButton 设置 fab_title 属性就行了，从属性名就可以看出来 fab_labelStyle 设置的是标签的的文本样式，fab_title 属性设置的是标签的文本内容，xml的写法如下: 123456789101112131415161718192021222324252627&lt;com.getbase.floatingactionbutton.FloatingActionsMenu android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" app:fab_labelStyle=\"@style/menu_labels_style\"&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:fabSize=\"mini\" app:fab_title=\"Text Document\"/&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:fabSize=\"mini\" app:fab_title=\"Spreadsheet\"/&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:fabSize=\"mini\" app:fab_title=\"Presentation\"/&gt;&lt;/com.getbase.floatingactionbutton.FloatingActionsMenu&gt; 显示的效果如下： 如果想要显示标签文字，那么必须设置 fab_labelStyle 属性，否则标签文字不会显示 FloatingActionButton 大概的用法就是这样，根据上面一些ui效果表现和xml布局用法，我们就可以得到如下信息： 上图中的 ‘+’ 号按钮是在 FloatinActionMenu 的代码中完成添加的，展开的悬浮按钮为 FloatinActionMenu 的子控件 当点击按钮时开始动画操作，从上图中能看到 3 个动画，第一个是 ‘+’ 号按钮的旋转动画，另外就是展开/折叠时的平移动画和透明渐变动画 当然只是上面这点东西还远远不能让我们知道 FloatingActionMenu 是怎么实现的，接下来就让我们开始分析 FloatingActionMenu 的代码吧。 FloatingActionMenu 解析首先我先说下 FloatingActionMenu 调用的大致流程，如下： 初始化时调用 init() 方法获取如 fab_labelStyle 等属性，然后调用 createAddButton() 方法添加 ‘+’ 号按钮。 重写 onFinishInflate() 方法，调用 createLabels() 方法创建标签文字。 重写 onMeasure() 方法，设置控件的大小。 重写 onLayout() 方法，对子控件进行布局。 当点击 ‘+’ 号按钮的时候菜单展开/折叠。 接下来就让我们按照上面的顺序对 FloatingActionMenu 进行分析。 一、init()1234567891011121314151617181920212223242526272829303132333435363738private void init(Context context, AttributeSet attributeSet) &#123; mButtonSpacing = (int) (getResources().getDimension(R.dimen.fab_actions_spacing) - getResources().getDimension(R.dimen.fab_shadow_radius) - getResources().getDimension(R.dimen.fab_shadow_offset)); mLabelsMargin = getResources().getDimensionPixelSize(R.dimen.fab_labels_margin); mLabelsVerticalOffset = getResources().getDimensionPixelSize(R.dimen.fab_shadow_offset); //用于控制标签文字的触摸动作 mTouchDelegateGroup = new TouchDelegateGroup(this); setTouchDelegate(mTouchDelegateGroup); TypedArray attr = context.obtainStyledAttributes(attributeSet, R.styleable.FloatingActionsMenu, 0, 0); //'+'号的颜色 mAddButtonPlusColor = attr.getColor(R.styleable.FloatingActionsMenu_fab_addButtonPlusIconColor, getColor(android.R.color.white)); //'+'号按钮正常状态下颜色 mAddButtonColorNormal = attr.getColor(R.styleable.FloatingActionsMenu_fab_addButtonColorNormal, getColor(android.R.color.holo_blue_dark)); //'+'号按钮按下颜色 mAddButtonColorPressed = attr.getColor(R.styleable.FloatingActionsMenu_fab_addButtonColorPressed, getColor(android.R.color.holo_blue_light)); //'+'号的大小，同FloatingActionButton里面的size mAddButtonSize = attr.getInt(R.styleable.FloatingActionsMenu_fab_addButtonSize, FloatingActionButton.SIZE_NORMAL); //'+'号边框是否可见，同FloatingActionButton里面的StrokeVisible mAddButtonStrokeVisible = attr.getBoolean(R.styleable.FloatingActionsMenu_fab_addButtonStrokeVisible, true); //菜单展开方向 //up '+'号按钮在下菜单向上弹出，bottom与其相反。 //right '+'号按钮在左菜单向右弹出 left与其相反 mExpandDirection = attr.getInt(R.styleable.FloatingActionsMenu_fab_expandDirection, EXPAND_UP); //标签文字的文本样式，如果为0则不会显示label文字 mLabelsStyle = attr.getResourceId(R.styleable.FloatingActionsMenu_fab_labelStyle, 0); //标签文字的位置，只能是 left or right mLabelsPosition = attr.getInt(R.styleable.FloatingActionsMenu_fab_labelsPosition, LABELS_ON_LEFT_SIDE); attr.recycle(); if (mLabelsStyle != 0 &amp;&amp; expandsHorizontally()) &#123; //当mExpandDirection = left or mExpandDirection = right 不能设置标签文字的文本样式 throw new IllegalStateException(\"Action labels in horizontal expand orientation is not supported.\"); &#125; //创建 '+' 号按钮 createAddButton(context);&#125; init() 里的代码都很好理解，第 7~8 行的mTouchDelegateGroup 是用于处理标签文字的触摸事件，基本上调用者只会对悬浮按钮也就是 FloatingActionButton 设置点击监听，这时候如果点击标签文字那么将会没有任何反应，如果在为标签文字设置一次点击监听，感觉又是多余的操作，mTouchDelegateGroup 就是为了解决这个问题，mTouchDelegateGroup 继承自 TouchDelegate 可以将标签文字的触摸事件传递给 FloatingActionButton 让其进行处理，最后的 createAddButton() 按钮，这个按钮就是点击后菜单就会展开/折叠的 ‘+’ 号按钮，具体代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void createAddButton(Context context) &#123; mAddButton = new AddFloatingActionButton(context) &#123; @Override void updateBackground() &#123; mPlusColor = mAddButtonPlusColor; mColorNormal = mAddButtonColorNormal; mColorPressed = mAddButtonColorPressed; mStrokeVisible = mAddButtonStrokeVisible; super.updateBackground(); &#125; @Override Drawable getIconDrawable() &#123; final RotatingDrawable rotatingDrawable = new RotatingDrawable(super.getIconDrawable()); mRotatingDrawable = rotatingDrawable; //菜单折叠动画 角度 90 + 45 到 0 final ObjectAnimator collapseAnimator = ObjectAnimator.ofFloat(rotatingDrawable, \"rotation\", EXPANDED_PLUS_ROTATION, COLLAPSED_PLUS_ROTATION); //菜单展开动画 角度 0 到 90 + 45 final ObjectAnimator expandAnimator = ObjectAnimator.ofFloat(rotatingDrawable, \"rotation\", COLLAPSED_PLUS_ROTATION, EXPANDED_PLUS_ROTATION); //设置插值器 使动画的旋转角度会先大于设定的结束值，然后在回到结束值 final OvershootInterpolator interpolator = new OvershootInterpolator(); collapseAnimator.setInterpolator(interpolator); expandAnimator.setInterpolator(interpolator); //放入AnimatorSet mExpandAnimation.play(expandAnimator); mCollapseAnimation.play(collapseAnimator); return rotatingDrawable; &#125; &#125;; mAddButton.setId(R.id.fab_expand_menu_button); mAddButton.setSize(mAddButtonSize); mAddButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; toggle(); &#125; &#125;); addView(mAddButton, super.generateDefaultLayoutParams()); mButtonsCount++;&#125; createAddButton() 方法做的事情很简单就是创建一个 AddFloatingActionButton 然后调用 addView() 添加到控件里，第四行的 toggle() 就是会将菜单展开/折叠的方法，这个方面后面再说。我们先来看看 AddFloatingActionButton 是什么东西。 AddFloatingActionButton 继承自 FloatingActionButton，它重写了 getIconDrawable() 方法不再根据调用者给予的图片资源设置图标，而是使用 ShapeDrawable 画了一个 ‘+’ 图片，也就是上面图片中可以看到的悬浮按钮里的 ‘+’ 号，代码就不贴出来了。 在这里 mAddButton 实例化的时候再次重写了 getIconDrawable() 和 updateBackground() 方法，updateBackground() 很简单就不说了，主要是 getIconDrawable() ，这个方法主要做的事情就是，创建 2 个对 ‘+’ 号按钮进行旋转操作的属性动画，这 2 个动画分别对应展开时的旋转动画和折叠时的旋转动画，然后将这 2 个旋转动画放入对应的动画集合中，到这里我们应该还能猜到，后面应该还会有展开/折叠时相对应的平移动画和透明渐变动画会加入到这 2 个动画合集中。 另外 RotatingDrawable 是一个自定义类 继承自 LayerDrawable 这是一个用于配合上面的属性动画使用的 Drawable，代码如下： 1234567891011121314151617181920212223242526private static class RotatingDrawable extends LayerDrawable &#123; public RotatingDrawable(Drawable drawable) &#123; super(new Drawable[]&#123;drawable&#125;); &#125; private float mRotation; @SuppressWarnings(\"UnusedDeclaration\") public float getRotation() &#123; return mRotation; &#125; @SuppressWarnings(\"UnusedDeclaration\") public void setRotation(float rotation) &#123; mRotation = rotation; invalidateSelf(); &#125; @Override public void draw(Canvas canvas) &#123; canvas.save(); canvas.rotate(mRotation, getBounds().centerX(), getBounds().centerY()); super.draw(canvas); canvas.restore(); &#125;&#125; 到这里第一步的 init() 就解析完了，init() 主要做的事情就 3 样 获取自定义的一些属性如 fab_labelStyle 、fab_expandDirection 等。 创建一个 AddFloatingActionButton 对象并重写 getIconDrawable 方法。并创建属性动画用于改变其角度让其旋转（此处的 AnimatorSet 拥有了第一个动画：旋转动画） 设置点击监听上图中的展开/折叠动画都是在这个监听里开始的 调用addView()将这个按钮添加到菜单中 二、onFinishInflate()onFinishInflate() 方法会在所有子控件从xml中 inflate 完后调用。也是 FloatingActionsMenu 这个类里面在 init() 之后被调用的方法，先来看下代码： 12345678910@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); //改变位置 将mAddButton 放到最前面 bringChildToFront(mAddButton); mButtonsCount = getChildCount(); if (mLabelsStyle != 0) &#123; createLabels(); &#125;&#125; 方法很简单，先是调用 bringChildToFront(mAddButton) 将上面刚刚添加到控件中的 ‘+’ 号按钮的顺序改变，在调用这个方法之前 mAddButton 顺序是在最前面这样绘制的时候 mAddButton 就会在其他的悬浮按钮下面，调用之后 mAddButton 的顺序就会在最后面，绘制的时候就会在其他悬浮按钮的上面了，之后如果 mLabelsStyle 不等 0 的话就会调用 createLabels() 创建标签文字，可以看到如果想显示标签文字那么就必须设置 fab_labelStyle 属性，同时在各位应该还记得在 init() 中如果菜单的弹出方向是 left 或 or 的话那么就不能设置 fab_labelStyle 属性，否则将会报异常。 接下来让我们来看 createLabels() 里的代码： 12345678910111213141516171819private void createLabels() &#123; Context context = new ContextThemeWrapper(getContext(), mLabelsStyle); for (int i = 0; i &lt; mButtonsCount; i++) &#123; FloatingActionButton button = (FloatingActionButton) getChildAt(i); String title = button.getTitle(); //按钮为 '+' 号按钮 or 文字为空 or 已经设置过了 就跳过 if (button == mAddButton || title == null || button.getTag(R.id.fab_label) != null) continue; TextView label = new TextView(context); label.setTextAppearance(getContext(), mLabelsStyle); label.setText(button.getTitle()); addView(label); //用按钮的 tag 保存 TextView button.setTag(R.id.fab_label, label); &#125;&#125; 可以看到标签文字的创建时根据子控件 FloatingActionButton 的 Title 来创建的而且最后标签文字的 TextView 控件也是使用 FloatingActionButton 的 setTag() 方法来保持引用的。 onFinishInflate() 的代码很简单，就做了 2 件事情： 将 ‘+’ 号按钮的顺序放到其他悬浮按钮的后面，让其能够在绘制时出去其他悬浮按钮之上。 根据对应的 FloatingActionButton 的 Title 创建 TextView 然后加入到菜单中，最后使用 FloatingActionButton 的setTag 保持引用 三、onMeasure()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //测量所有子视图的大小 measureChildren(widthMeasureSpec, heightMeasureSpec); //控件的宽/高 int width = 0; int height = 0; //悬浮按钮最大宽度/高度 mMaxButtonWidth = 0; mMaxButtonHeight = 0; //标签文字最大长度 int maxLabelWidth = 0; for (int i = 0; i &lt; mButtonsCount; i++) &#123; View child = getChildAt(i); if (child.getVisibility() == GONE) &#123; continue; &#125; switch (mExpandDirection) &#123; case EXPAND_UP: case EXPAND_DOWN: //拿到childView最大的宽度 mMaxButtonWidth = Math.max(mMaxButtonWidth, child.getMeasuredWidth()); //菜单方向为竖向时 //将子控件的高度相加 height += child.getMeasuredHeight(); break; case EXPAND_LEFT: case EXPAND_RIGHT: //菜单方向为横向时 //将子控件的加宽度 width += child.getMeasuredWidth(); //拿到childView最大高度 mMaxButtonHeight = Math.max(mMaxButtonHeight, child.getMeasuredHeight()); break; &#125; if (!expandsHorizontally()) &#123; TextView label = (TextView) child.getTag(R.id.fab_label); if (label != null) &#123; //拿到标签文字最大的宽度 maxLabelWidth = Math.max(maxLabelWidth, label.getMeasuredWidth()); &#125; &#125; &#125; if (!expandsHorizontally()) &#123; //菜单弹出方向为竖向 //控件的宽度需要加上标签文字和边距的宽度 width = mMaxButtonWidth + (maxLabelWidth &gt; 0 ? maxLabelWidth + mLabelsMargin : 0); &#125; else &#123; height = mMaxButtonHeight; &#125; switch (mExpandDirection) &#123; case EXPAND_UP: case EXPAND_DOWN: height += mButtonSpacing * (mButtonsCount - 1); height = adjustForOvershoot(height); break; case EXPAND_LEFT: case EXPAND_RIGHT: width += mButtonSpacing * (mButtonsCount - 1); width = adjustForOvershoot(width); break; &#125; setMeasuredDimension(width, height);&#125; onMeasure() 还是比较长的，首先第 3 行的 measureChildren 方法显示把所有的子控件的大小给测量出来，这里我只分析下菜单方向为竖向时的情况，横向时也是大同小异就不重复说明了。 竖向 up or down 26~31 记录下悬浮按钮的最大宽度和所有悬浮按钮的总高度。 42~48 如果所对应的标签文字不为空的话那么会记录下最大的文字宽度。 54行 计算控件的宽度，宽度 = 悬浮按钮的最大宽度 + 标签文字的最大宽度 + 按钮和文字之间的间隔（如果标签文字为空，那么最终的宽度就是悬浮按钮的最大宽度） 62~64 计算控件的高度，高度 = (悬浮按钮的总高度 + 每个悬浮按钮之间的间隔之和) * 12 / 10。 控件高度计算里的 12 / 10 是哪里来的呢？其实这个就是 adjustForOvershoot 方法里干的事情，先来看下代码 123private int adjustForOvershoot(int dimension) &#123; return dimension * 12 / 10;&#125; 这里为什么要乘以 12/10 呢？还记之前看到的 gif 中菜单展开时候的效果吗？菜单展开时有个回弹的效果，这个是因为后面的代码里为属性动画设置了插值器 OvershootInterpolator ，设置了这个插值器后，动画到达结束位置时会再向后运动一定的值，之后再回到原来的结束位置。因此我们在设置高度的时候就避免动画过程中我们的子控件超出了控件范围。 最后调用 setMeasuredDimension 设置控件的大小 onMeasure 方法就结束了。 最后总结为，当菜单方向为竖向时： 标签文本不为空时 width = 悬浮按钮们的最大宽度 + 标签文字的最大宽度 + 2者的间距。 标签文本为空时 width = 悬浮按钮们的最大宽度。 height = (所有悬浮按钮的高度之和 + 所有悬浮按钮之间的间隔之和) * 12 / 10。 当菜单的方向为横向时： width = (所有悬浮按钮的宽度之和 + 所有悬浮按钮之间的间隔之和) * 12 / 10。 height = 悬浮按钮们的最大高度。 onLayout()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; switch (mExpandDirection) &#123; case EXPAND_UP: case EXPAND_DOWN: boolean expandUp = mExpandDirection == EXPAND_UP; if (changed) &#123; mTouchDelegateGroup.clearTouchDelegates(); &#125; //'+'号按钮Y轴位置 向上弹出则在下面 否则在上面 int addButtonY = expandUp ? b - t - mAddButton.getMeasuredHeight() : 0; // 确保按钮集中在一条直线上，计算出按钮居中点 buttonsHorizontalCenter // 如果标签文字在左边那么悬浮按钮就靠近父控件右边，标签文字在右边则反之 int buttonsHorizontalCenter = mLabelsPosition == LABELS_ON_LEFT_SIDE ? r - l - mMaxButtonWidth / 2 : mMaxButtonWidth / 2; //计算'+'号按钮左边位置 int addButtonLeft = buttonsHorizontalCenter - mAddButton.getMeasuredWidth() / 2; mAddButton.layout(addButtonLeft, addButtonY, addButtonLeft + mAddButton.getMeasuredWidth(), addButtonY + mAddButton.getMeasuredHeight()); //标签文字的偏移量 int labelsOffset = mMaxButtonWidth / 2 + mLabelsMargin; //标签文字在按钮左边时 标签文字的 right 坐标，在右边时 文字的 left 坐标 int labelsXNearButton = mLabelsPosition == LABELS_ON_LEFT_SIDE ? buttonsHorizontalCenter - labelsOffset : buttonsHorizontalCenter + labelsOffset; //下一个按钮的Y轴坐标 int nextY = expandUp ? addButtonY - mButtonSpacing : addButtonY + mAddButton.getMeasuredHeight() + mButtonSpacing; for (int i = mButtonsCount - 1; i &gt;= 0; i--) &#123; final View child = getChildAt(i); if (child == mAddButton || child.getVisibility() == GONE) continue; //按钮的left int childX = buttonsHorizontalCenter - child.getMeasuredWidth() / 2; //按钮的top int childY = expandUp ? nextY - child.getMeasuredHeight() : nextY; child.layout(childX, childY, childX + child.getMeasuredWidth(), childY + child.getMeasuredHeight()); float collapsedTranslation = addButtonY - childY; float expandedTranslation = 0f; //mExpanded = false 平移到'+'按钮的位置 child.setTranslationY(mExpanded ? expandedTranslation : collapsedTranslation); //mExpanded = false 透明度设置为0 child.setAlpha(mExpanded ? 1f : 0f); //设置属性动画 LayoutParams params = (LayoutParams) child.getLayoutParams(); //设置折叠动画平移的开始和结束值 params.mCollapseDir.setFloatValues(expandedTranslation, collapsedTranslation); //设置展开动画平移的开始和结束值 params.mExpandDir.setFloatValues(collapsedTranslation, expandedTranslation); //设置动画的目标对象为child 悬浮按钮按钮，并加入到动画集合中 params.setAnimationsTarget(child); View label = (View) child.getTag(R.id.fab_label); if (label != null) &#123; //和labelsXNearButton相反 //标签文字在左边时,文字的 left 坐标,标签文字在右边时 文字的 right 坐标 int labelXAwayFromButton = mLabelsPosition == LABELS_ON_LEFT_SIDE ? labelsXNearButton - label.getMeasuredWidth() : labelsXNearButton + label.getMeasuredWidth(); int labelLeft = mLabelsPosition == LABELS_ON_LEFT_SIDE ? labelXAwayFromButton : labelsXNearButton; int labelRight = mLabelsPosition == LABELS_ON_LEFT_SIDE ? labelsXNearButton : labelXAwayFromButton; int labelTop = childY - mLabelsVerticalOffset + (child.getMeasuredHeight() - label.getMeasuredHeight()) / 2; label.layout(labelLeft, labelTop, labelRight, labelTop + label.getMeasuredHeight()); //用于处理标签文字的触摸事件,将其范围内的触摸事件交给对应的FloatingActionButton处理 Rect touchArea = new Rect( Math.min(childX, labelLeft), childY - mButtonSpacing / 2, Math.max(childX + child.getMeasuredWidth(), labelRight), childY + child.getMeasuredHeight() + mButtonSpacing / 2); mTouchDelegateGroup.addTouchDelegate(new TouchDelegate(touchArea, child)); //行为同按钮 label.setTranslationY(mExpanded ? expandedTranslation : collapsedTranslation); label.setAlpha(mExpanded ? 1f : 0f); //和上面按钮的动画设置相同 LayoutParams labelParams = (LayoutParams) label.getLayoutParams(); labelParams.mCollapseDir.setFloatValues(expandedTranslation, collapsedTranslation); labelParams.mExpandDir.setFloatValues(collapsedTranslation, expandedTranslation); labelParams.setAnimationsTarget(label); &#125; nextY = expandUp ? childY - mButtonSpacing : childY + child.getMeasuredHeight() + mButtonSpacing; &#125; break; case EXPAND_LEFT: case EXPAND_RIGHT: boolean expandLeft = mExpandDirection == EXPAND_LEFT; int addButtonX = expandLeft ? r - l - mAddButton.getMeasuredWidth() : 0; // Ensure mAddButton is centered on the line where the buttons should be int addButtonTop = b - t - mMaxButtonHeight + (mMaxButtonHeight - mAddButton.getMeasuredHeight()) / 2; mAddButton.layout(addButtonX, addButtonTop, addButtonX + mAddButton.getMeasuredWidth(), addButtonTop + mAddButton.getMeasuredHeight()); int nextX = expandLeft ? addButtonX - mButtonSpacing : addButtonX + mAddButton.getMeasuredWidth() + mButtonSpacing; for (int i = mButtonsCount - 1; i &gt;= 0; i--) &#123; final View child = getChildAt(i); if (child == mAddButton || child.getVisibility() == GONE) continue; int childX = expandLeft ? nextX - child.getMeasuredWidth() : nextX; int childY = addButtonTop + (mAddButton.getMeasuredHeight() - child.getMeasuredHeight()) / 2; child.layout(childX, childY, childX + child.getMeasuredWidth(), childY + child.getMeasuredHeight()); float collapsedTranslation = addButtonX - childX; float expandedTranslation = 0f; child.setTranslationX(mExpanded ? expandedTranslation : collapsedTranslation); child.setAlpha(mExpanded ? 1f : 0f); LayoutParams params = (LayoutParams) child.getLayoutParams(); params.mCollapseDir.setFloatValues(expandedTranslation, collapsedTranslation); params.mExpandDir.setFloatValues(collapsedTranslation, expandedTranslation); params.setAnimationsTarget(child); nextX = expandLeft ? childX - mButtonSpacing : childX + child.getMeasuredWidth() + mButtonSpacing; &#125; break; &#125;&#125; onLayout() 里同样也只对竖向的情况进行分析注释，上面的方法中大部分都是对按钮和标签文字的位置计算，我也做了详细的注释，就不多说了。 可以看下 50~57 行以及 90~94 行，50~57 行是对悬浮按钮设置动画效果，90~94 行是对标签文字设置动画效果，过程都是一样的，都是通过自定义的 LayoutParams 来进行设置，我们先来看下这个自定义 LayoutParams 的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private static Interpolator sExpandInterpolator = new OvershootInterpolator();private static Interpolator sCollapseInterpolator = new DecelerateInterpolator(3f);private static Interpolator sAlphaExpandInterpolator = new DecelerateInterpolator();private class LayoutParams extends ViewGroup.LayoutParams &#123; /*菜单展开时的平移和透明渐变动画*/ private ObjectAnimator mExpandDir = new ObjectAnimator(); private ObjectAnimator mExpandAlpha = new ObjectAnimator(); /*菜单折叠时的平移和透明渐变动画*/ private ObjectAnimator mCollapseDir = new ObjectAnimator(); private ObjectAnimator mCollapseAlpha = new ObjectAnimator(); private boolean animationsSetToPlay; public LayoutParams(ViewGroup.LayoutParams source) &#123; super(source); mExpandDir.setInterpolator(sExpandInterpolator); mExpandAlpha.setInterpolator(sAlphaExpandInterpolator); mCollapseDir.setInterpolator(sCollapseInterpolator); mCollapseAlpha.setInterpolator(sCollapseInterpolator); //收起透明动画 不透明 -&gt; 透明 mCollapseAlpha.setProperty(View.ALPHA); mCollapseAlpha.setFloatValues(1f, 0f); //展开透明动画 透明 -&gt; 不透明 mExpandAlpha.setProperty(View.ALPHA); mExpandAlpha.setFloatValues(0f, 1f); switch (mExpandDirection) &#123; case EXPAND_UP: case EXPAND_DOWN: //Y轴方向上平移 mCollapseDir.setProperty(View.TRANSLATION_Y); mExpandDir.setProperty(View.TRANSLATION_Y); break; case EXPAND_LEFT: case EXPAND_RIGHT: //X轴方向上平移 mCollapseDir.setProperty(View.TRANSLATION_X); mExpandDir.setProperty(View.TRANSLATION_X); break; &#125; &#125; public void setAnimationsTarget(View view) &#123; //设置动画目标视图 mCollapseAlpha.setTarget(view); mCollapseDir.setTarget(view); mExpandAlpha.setTarget(view); mExpandDir.setTarget(view); // Now that the animations have targets, set them to be played //动画集合还没有添加成功进入语句 if (!animationsSetToPlay) &#123; //动画监听 addLayerTypeListener(mExpandDir, view); addLayerTypeListener(mCollapseDir, view); //将透明动画平移动画加入到动画集合中 mCollapseAnimation.play(mCollapseAlpha); mCollapseAnimation.play(mCollapseDir); mExpandAnimation.play(mExpandAlpha); mExpandAnimation.play(mExpandDir); animationsSetToPlay = true; &#125; &#125; private void addLayerTypeListener(Animator animator, final View view) &#123; animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; //view按一般方式绘制，不使用离屏缓冲．这是默认的行为． view.setLayerType(LAYER_TYPE_NONE, null); &#125; @Override public void onAnimationStart(Animator animation) &#123; //如果应用被硬加速了，view会被绘制到一个硬件纹理中 //如果应用没被硬加速，此类型的layer的行为同于LAYER_TYPE_SOFTWARE． view.setLayerType(LAYER_TYPE_HARDWARE, null); &#125; &#125;); &#125;&#125; LayoutParams 拥有4个属性动画，这 4 个属性动画就是我们上面分析时所需要的平移和透明渐变动画，在 setAnimationsTarget() 被调用时会被加入到动画集合中，这样我们动画集合所需要的旋转、平移、透明渐变，这几个动画效果就都具备了。 onLayout 所做的事情就是计算子控件的位置以及对其进行布局，另外还会对对每个悬浮按钮和对应的标签文字设置展开和折叠时的平移和透明渐变动画，然后将这些动画加入到动画合集中，达到让这些动画能同时开始的目的。 toggle 展开/折叠的开关123456789101112131415161718192021222324252627282930313233343536373839404142434445public void toggle() &#123; if (mExpanded) &#123; collapse(); &#125; else &#123; expand(); &#125;&#125;public void collapse() &#123; collapse(false);&#125;/** * 折叠菜单 * @param immediately 是否马上折叠（没有动画过程） */private void collapse(boolean immediately) &#123; if (mExpanded) &#123; mExpanded = false; mTouchDelegateGroup.setEnabled(false); mCollapseAnimation.setDuration(immediately ? 0 : ANIMATION_DURATION); mCollapseAnimation.start(); mExpandAnimation.cancel(); if (mListener != null) &#123; mListener.onMenuCollapsed(); &#125; &#125;&#125;/** * 展开菜单 */public void expand() &#123; if (!mExpanded) &#123; mExpanded = true; mTouchDelegateGroup.setEnabled(true); mCollapseAnimation.cancel(); mExpandAnimation.start(); if (mListener != null) &#123; mListener.onMenuExpanded(); &#125; &#125;&#125; toggle() 方法是 ‘+’ 号按钮的点击监听中调用的方法，代码还是非常简单的，因为我们在之前的代码中已经将展开和折叠所需要的所有属性动画放入到了相应的动画集合中了，在这里只需要调用动画集合的 start() 这个菜单控件就能达到最开始 gif 里面的效果了。 最后FloatingActionMenu 并不复杂，整个过程如下： 初始化时调用 addView() 方法添加一个 ‘+’ 号按钮，这个按钮也就是菜单展开/折叠的开关，在这里会创建展开/折叠时的旋转动画，并加入到相应的动画集合中 重写 onFinishInflate() 方法在所有子控件 (FloatingActionButton) 添加完成后，获取子控件的 Title 后创建 TextView 加入到 FloatingActionMenu 中(Title 通过 FloatingActionButton 的 fab_title 属性设置), 重写 onMeasure() 方法设置控件的大小 重写 onLayout() 方法设置子控件的位置，并且为每一个子控件(FloatingActionButton 和 上面添加的标签文字TextView)设置展开/折叠时的平移、透明渐变动画，加入到动画集合中。 用户点击 ‘+’ 号按钮时触发初始化时为其设置的点击监听，toggle() 方法被调用根据当前的状态(展开还是折叠)调用相应的展开否折叠动画。 以上就是 FloatingActionMenu 实现的全部过程，感谢您的阅读。","raw":null,"content":null,"categories":null,"tags":[{"name":"Android第三方开源项目解析","slug":"Android第三方开源项目解析","permalink":"http://yoursite.com/tags/Android第三方开源项目解析/"}]},{"title":"第三方控件 android floating action button 解析 (part1) - FloatingActionButton","slug":null,"date":"2016-03-03T03:13:00.000Z","updated":null,"comments":null,"path":"2016/03/03/2016030311_android_floating_action_button_part1/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"android-floating-action-button 是github上的开源库,是根据 Material Design 中提到的 Floating action button 所写的。支持的最低版本号为 14。如果你需要支持旧的android版本可以使用他人维护的另外一个版本，这一版本的的 minSdkVersion = 4。另外FloatingActionButton这个库没有实现 ‘快速返回’ （原文中是 ‘quick return’ 不知道没有没更好的说法）这个功能，即按钮在列表向下滚时消失，向上滚时显示。作者认为这个功能应该由另外一个组件来实现，而不是按钮本身来做这件事情。如果你需要这一功能可以使用 Oleksandr Melnykov 的 FloatingActionButton ，这个库就是以本文的 android-floating-action-button 为基础所写的。 FloatingActionButtonFloatingActionButton 是这个库里面的最基础的控件，只要简单的在 xml 引用它，并进行简单的配置就可以实现如下效果 下面就让我们来看看这样一个悬浮按钮到底是怎么实现的吧 初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FloatingActionButton extends ImageButton &#123; public FloatingActionButton(Context context) &#123; this(context, null); &#125; public FloatingActionButton(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; public FloatingActionButton(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(context, attrs); &#125; void init(Context context, AttributeSet attributeSet) &#123; TypedArray attr = context.obtainStyledAttributes(attributeSet, R.styleable.FloatingActionButton, 0, 0); //正常状态下按钮的颜色 mColorNormal = attr.getColor(R.styleable.FloatingActionButton_fab_colorNormal, getColor(android.R.color.holo_blue_dark)); //点击时按钮的颜色 mColorPressed = attr.getColor(R.styleable.FloatingActionButton_fab_colorPressed, getColor(android.R.color.holo_blue_light)); //被禁用时按钮的颜色 enabled = false mColorDisabled = attr.getColor(R.styleable.FloatingActionButton_fab_colorDisabled, getColor(android.R.color.darker_gray)); //mSize决定悬浮圆形(不包括阴影)的大小 mSize = attr.getInt(R.styleable.FloatingActionButton_fab_size, SIZE_NORMAL); //按钮图标 mIcon = attr.getResourceId(R.styleable.FloatingActionButton_fab_icon, 0); //展开时的标签文字,仅当FloatingActionButton 是 FloatingActionMenu 的 mTitle = attr.getString(R.styleable.FloatingActionButton_fab_title); //是否显示边框线 mStrokeVisible = attr.getBoolean(R.styleable.FloatingActionButton_fab_stroke_visible, true); attr.recycle(); updateCircleSize(); //阴影半径 mShadowRadius = 9dp mShadowRadius = getDimension(R.dimen.fab_shadow_radius); //阴影偏移量 mShadowOffset = 3dp mShadowOffset = getDimension(R.dimen.fab_shadow_offset); updateDrawableSize(); updateBackground(); &#125;&#125; FloatingActionButton继承自ImageButton，所有的构造方法最终都会调用 init() ，init() 我做了详细的注释，关于 mShadowRadius 和 mShadowOffset 这2个变量后面会解释，这里就先跳过。 第35行的 updateCircleSize() 根据 mSize 确定 mCircleSize 等于 56dp 还是 40dp ，mCircleSize 的大小其实就是悬浮圆形的大小，代码如下 123456/** * 设置mCircleSize的值 如果 mSize = SIZE_NORMAL 则圆为56dp , mSize = SIZE_MINI 则圆为40dp */private void updateCircleSize() &#123; mCircleSize = getDimension(mSize == SIZE_NORMAL ? R.dimen.fab_size_normal : R.dimen.fab_size_mini);&#125; 第40行的 updateDrawableSize() 根据悬浮圆形的 size 和阴影的长度计算这个自定义 View 的 size，mDrawableSize 其实就是 View 长和宽，我们可以把 onMeasure 贴出来一起看下，代码如下： 123456789101112/** * 计算view的大小, 圆大小 + 左右两边的阴影长度 */private void updateDrawableSize() &#123; mDrawableSize = (int) (mCircleSize + 2 * mShadowRadius);&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); setMeasuredDimension(mDrawableSize, mDrawableSize);&#125; onMeasure() 里面的代码非常的简单，仅仅只是调用了 setMeasuredDimension() 设置控件的长和宽。 最后第42行的 updateBackground() 就是重头戏了，我们先来看下代码 1234567891011121314151617181920212223242526272829303132333435363738394041void updateBackground() &#123; final float strokeWidth = getDimension(R.dimen.fab_stroke_width); final float halfStrokeWidth = strokeWidth / 2f; LayerDrawable layerDrawable = new LayerDrawable(new Drawable[]&#123; getResources().getDrawable(mSize == SIZE_NORMAL ? R.drawable.fab_bg_normal : R.drawable.fab_bg_mini), createFillDrawable(strokeWidth), createOuterStrokeDrawable(strokeWidth), getIconDrawable() &#125;); int iconOffset = (int) (mCircleSize - getDimension(R.dimen.fab_icon_size)) / 2; int circleInsetHorizontal = (int) (mShadowRadius); int circleInsetTop = (int) (mShadowRadius - mShadowOffset); int circleInsetBottom = (int) (mShadowRadius + mShadowOffset); //第二层drawable 设置圆的偏移量 setLayerInset(layer, leftOffset, topOffset, rightOffset, bottomOffset) layerDrawable.setLayerInset(1, circleInsetHorizontal, circleInsetTop, circleInsetHorizontal, circleInsetBottom); //第三层drawable 设置最外层边框的偏移量 layerDrawable.setLayerInset(2, (int) (circleInsetHorizontal - halfStrokeWidth), (int) (circleInsetTop - halfStrokeWidth), (int) (circleInsetHorizontal - halfStrokeWidth), (int) (circleInsetBottom - halfStrokeWidth)); //第四层drawable 将图标设置为居中 layerDrawable.setLayerInset(3, circleInsetHorizontal + iconOffset, circleInsetTop + iconOffset, circleInsetHorizontal + iconOffset, circleInsetBottom + iconOffset); //设置背景图片 setBackgroundCompat(layerDrawable);&#125; 首先让我们忽略中间的一堆代码，只看第 5 行和第 40 行，就会发现这段代码还是蛮简单的，第 5 行创建了一个 Drawable，第 40 行调用 setBackgroundCompat() 设置背景图片。其实就是我们平常的设置背景图片的过程，重点就是怎么为这个 Drawable 加上圆形、阴影、点击变色等效果了，首先我们需要先了解下 LayerDrawable 是什么东西。 LayerDrawableLayerDrawable是Drawable的子类，这是一个用于管理 Drawable 的数组，可以将Drawable按照顺序进行绘制，拥有最大索引的 Drawable 将被绘制在最上层，它可以对应xml中的 layer-list比如在 drawable/layer.xml 中 1234&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@android:color/white\" /&gt; &lt;item android:drawable=\"@drawable/logo\" /&gt; &lt;/layer-list&gt; 第一层 png 图片了解完后我们来看上面代码创建的LayerDrawable 123456LayerDrawable layerDrawable = new LayerDrawable(new Drawable[]&#123; getResources().getDrawable(mSize == SIZE_NORMAL ? R.drawable.fab_bg_normal : R.drawable.fab_bg_mini),//第一层 createFillDrawable(strokeWidth),//第二层 createOuterStrokeDrawable(strokeWidth),//第三层 getIconDrawable()//第四层&#125;); 第一层的 Drawable 是一张图片，根据 mSize 来决定是使用 fab_bg_normal 还是 fab_bg_mini 之前也说 mSize 决定了 mCircleSize 也就是悬浮圆的大小 ，这里面似乎有某种关系？我们先来看看 fab_bg_normal 是什么样子的( fab_bg_mini 只是小了一号就不贴出了)。 其实如果仔细观察图片的大小，圆形的大小，以及阴影的长度就能发现mDrawableSize (上文中在 onMeasure() 方法内设置的长和宽)就是 fab_bg_normal 图片的大小，mCircleSize 就是图中圆形的大小，mShadowRadius 就是图片中左右两边的阴影长度，mShadowOffset 是Y轴上的偏移量，向上偏移是为了加重底部的阴影，如下图所示。 第二层 圆形填充Drawable12345678910private StateListDrawable createFillDrawable(float strokeWidth) &#123; StateListDrawable drawable = new StateListDrawable(); //禁用drawable drawable.addState(new int[]&#123;-android.R.attr.state_enabled&#125;, createCircleDrawable(mColorDisabled, strokeWidth)); //按下drawable drawable.addState(new int[]&#123;android.R.attr.state_pressed&#125;, createCircleDrawable(mColorPressed, strokeWidth)); //正常drawable drawable.addState(new int[]&#123;&#125;, createCircleDrawable(mColorNormal, strokeWidth)); return drawable;&#125; 这里创建了一个StateListDrawable，然后为这个StateListDrawable创建了3种状态下的Drawable。分别是按钮被禁用时显示的Drawable，按钮被点击时显示的Drawable，按钮正常状态下的Drawable。如果不知道StateListDrawable是什么的话，那么看看下面的xml写法应该就懂了吧？ 12345&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/disabled\" android:state_enabled=\"false\"/&gt; &lt;item android:drawable=\"@drawable/pressed\" android:state_pressed=\"true\"/&gt; &lt;item android:drawable=\"@drawable/normal\"/&gt;&lt;/selector&gt; 我们平时经常写的 selector 最后都是会转换成 StateListDrawable 的。了解了 StateListDrawable 就让我们继续看 createCircleDrawable() 这个方法，看名字应该就能猜到这个方法应该是创建一个圆形的Drawable。 12345678910111213141516171819202122232425262728293031private Drawable createCircleDrawable(int color, float strokeWidth) &#123; //拿到color中的透明度 int alpha = Color.alpha(color); //将color中的透明度去掉 int opaqueColor = opaque(color); //创建圆形的Drawable ShapeDrawable fillDrawable = new ShapeDrawable(new OvalShape()); final Paint paint = fillDrawable.getPaint(); //抗锯齿 paint.setAntiAlias(true); //设置画笔颜色 paint.setColor(opaqueColor); Drawable[] layers = &#123; fillDrawable, createInnerStrokesDrawable(opaqueColor, strokeWidth)//渐变边框 &#125;; //根据是否有透明度和是否显示边框来决定填充色是否显示透明 LayerDrawable drawable = alpha == 255 || !mStrokeVisible ? new LayerDrawable(layers) : new TranslucentLayerDrawable(alpha, layers); //边框线的内边距 int halfStrokeWidth = (int) (strokeWidth / 2f); drawable.setLayerInset(1, halfStrokeWidth, halfStrokeWidth, halfStrokeWidth, halfStrokeWidth); return drawable;&#125; 能看到 createCircleDrawable() 确实是创建了一个圆，而且还在这个圆上画了一个颜色渐变的边框，createInnerStrokesDrawable() 里做的事情就是将传入的 color 调亮或调暗或是改变透明度然后用着几个颜色做一个颜色渐变的边框，具体的代码就不贴出来了。第 22 行决定了圆的填充色是否要透明，28 行为这个渐变边框设置上下左右的偏移量（可以对照我们平时写布局时的layout_marginBottom、layout_marginTop来理解）。 到这里第二层 Drawable 就创建完成了，当然我们还需要为第二层的 Drawable 设置偏移量，也就是 updateBackground() 里的这一段代码 12345678910int circleInsetHorizontal = (int) (mShadowRadius);int circleInsetTop = (int) (mShadowRadius - mShadowOffset);int circleInsetBottom = (int) (mShadowRadius + mShadowOffset);//第二层drawable 设置圆的偏移量 setLayerInset(layer, leftOffset, topOffset, rightOffset, bottomOffset)layerDrawable.setLayerInset(1, circleInsetHorizontal, circleInsetTop, circleInsetHorizontal, circleInsetBottom); circleInsetHorizontal = 9dp，circleInsetTop = 6dp，circleInsetBottom = 12dp。可以发现设置偏移量后第二层的圆形 Drawable 刚好盖在了第一层图片的圆形上面。这二层 Drawable 叠加后的效果如图所示 如果仔细观察也能看到悬浮圆形周围一圈有一个颜色渐变的圆环 第三层 黑色的圆形边框线123456789101112131415161718192021private Drawable createOuterStrokeDrawable(float strokeWidth) &#123; ShapeDrawable shapeDrawable = new ShapeDrawable(new OvalShape()); final Paint paint = shapeDrawable.getPaint(); paint.setAntiAlias(true); paint.setStrokeWidth(strokeWidth); paint.setStyle(Style.STROKE); paint.setColor(Color.BLACK); paint.setAlpha(opacityToAlpha(0.02f)); return shapeDrawable;&#125;....//第三层drawable 设置最外层边框的偏移量layerDrawable.setLayerInset(2, (int) (circleInsetHorizontal - halfStrokeWidth), (int) (circleInsetTop - halfStrokeWidth), (int) (circleInsetHorizontal - halfStrokeWidth), (int) (circleInsetBottom - halfStrokeWidth));.... 为了方便起见，将 updateBackground() 中的代码片段在了下面，代码非常的简单就不多解释了，值得一提的是，叠加上这一层 Drawable 后按钮便有2个边框了，一个是第二层的渐变边框，还有就是现在这个黑色的外边框了。 第四层 icon1234567891011121314151617181920Drawable getIconDrawable() &#123; if (mIconDrawable != null) &#123; return mIconDrawable; &#125; else if (mIcon != 0) &#123; return getResources().getDrawable(mIcon); &#125; else &#123; return new ColorDrawable(Color.TRANSPARENT); &#125;&#125;...//fab_icon_size = 24dpint iconOffset = (int) (mCircleSize - getDimension(R.dimen.fab_icon_size)) / 2;//第四层drawable 将图标设置为居中layerDrawable.setLayerInset(3, circleInsetHorizontal + iconOffset, circleInsetTop + iconOffset, circleInsetHorizontal + iconOffset, circleInsetBottom + iconOffset);... getIconDrawable() 如果没有设置图标的话就返回一个透明的 ColorDrawable ，非常简单的逻辑。最后设置图标的偏移量让其居中，而且从这里也可以看出来，不管圆的大小是 56dp 还是 40dp 图标的大小都是 24dp。 最后FloatingActionButton 的代码其实非常的简单，首先根据 根据阴影底图也就是 fab_bg_norma/fab_bg_mini 赋值mShadowRadius = 9dp ，mShadowOffset = 3dp ，mCircleSize = 56dp/40dp ，mDrawableSize就是图片的大小。之后创建了一个 LayerDrawable，这个 LayerDrawable 总共有4层，系统会按照这些 Drawable 的顺序来绘制他们，这四份分别是： 第一层：阴影底图 fab_bg_normal/fab_bg_mini 。 第二层：一个填充圆和渐变的圆环。 第三层：一个黑色的圆环，这个圆环是包围第二层的填充圆的。 第四层：调用者设置的图标，这个图标的大小是24dp，且居中。 最后在调用 setBackground 或 setBackgroundDrawable(minSdkVersion &gt;= 16) 设置背景。 以上就是 FloatingActionButton 实现的全部过程，感谢您的阅读。","raw":null,"content":null,"categories":null,"tags":[{"name":"Android第三方开源项目解析","slug":"Android第三方开源项目解析","permalink":"http://yoursite.com/tags/Android第三方开源项目解析/"}]},{"title":"Activity的启动模式和匹配规则","slug":null,"date":"2016-02-27T09:25:00.000Z","updated":null,"comments":null,"path":"2016/02/27/2016022717_Activity的启动模式和匹配规则/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"博文内容来自《Android开发艺术探索》第一章Activity的生命周期和启动模式。 Activity是四大组件中我们接触的最多的一个组件，它非常的重要，所以有必要搞清楚他的启动模式和匹配规则 一、Activity的启动模式目前有四种启动模式：standard、singleTop、singleTask和singleInstance。 standardstandard即标准模式，是Activity默认指定的模式，每一次启动Activity，都会重新创建一个实例,一个任务栈可以有多个实例，每个实例可以属于不同的栈。在这种模式下谁启动了这个Activity，那么这个Activity就会运行在启动它的Activity所在的栈中。所以让我们使用非Activity类型的Context去启动standard模式的Activity时候就会报错，因为非Activity类型的Context（如AppplicationContext）并没有所谓的任务栈。解决办法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK（singleTask模式）标记位，这样启动它的时候就会为它创建一个新的任务栈。 singleTopsingleTop栈顶复用模式即。在这模式下，如果新的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以去取出当前请求的的信息。需要注意的是，这个Activity的onCreate、onStart不会被调用，因为它没有发生改变。如果新的Activity的实例已存在但不位于栈顶，那么就会重新创建一个新的Activity。 singleTask栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop，系统也会回调其onNewIntent。具体一点，当一个具有singleTask模式的Activity请求启动后，比如Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放入栈中。如果存在A所需要的任务栈，这是要看这个栈中是否存在A的实例，如果实例存在，那么就会将A调到栈顶，并调用onNewIntent方法，当然，由于任务栈是‘后进先出’的栈结构，系统需要先把A之上的Activity实例退出栈后才能将A调到栈顶，如果实例不存在，就创建A的实例并把A压入到栈中。 singleInstance单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它建一个新的任务栈，然后A独自在这个新的栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了。 补充 上面介绍了几种启动模式，这里需要指出一种情况，我们假设目前有2个任务栈， 前台任务栈的情况为AB，后台任务栈的情况为CD，假设CD的启动模式为singleTask。现在请求启动D，那么整个后台任务栈会被切换到前台，这个时候整个后退列表变成了ABCD，如果启动C，就会变为ABC了 在singleTask启动模式中，多次提到Activity所需要的任务栈，什么事Activity所需要的任务栈呢？这要从一个参数说起：TaskAffinity，这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需要的任务栈的名字为应用的包名相同。当然，我们可以为每个Activity单独指定TaskAffinity属性，这个属性不能和名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。另外，任务栈分为前台任务栈和后台任务栈，后台任务栈的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。 当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同任务栈中。 当TaskAffinity和allowTaskReparenting结合的时候，会产生特殊的效果。当一个应用A启动应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性为true的话，那么当应用B被启动后，此Activity会直接从应用的任务栈转移到应用B的任务栈中 如何给Activity指定启动模式呢？有下面两种方式 通过AndroidMenifest为Activity指定启动模式，这种方式直接为Activity设置FLAG_ACTIVITY_CLEAR_TOP标识 通过Intent中设置标志位来为Activity指定启动模式。这种方式无法为Activity指定singleInstance模式 二、Activity的FlagsActivitry的Flag有很多，这里主要分析一些比较常用的标记为。剩下的标记位读者可以查看官方文档去了解，大部分情况下，我们不需要为Activity指定标记位，因此，对于标记位理解即可。需要注意有些标记位是系统内部使用的，应用程序不需要去手动设置这些标记位 FLAG_ACTIVITY_NEW_TASK这个标记位的作用是为Activity指定 “singleTask” 启动模式，其效果和XML中指定该启动模式相同。 FLAG_ACTIVITY_SINGLE_TOP这个标记位的作用是为Activity指定 “singleTop”启动模式，其效果和XML中指定该启动模式相同。 FLAG_ACTIVITY_CLEAR_TOP具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动的Activity实例如何已经存在，那么系统会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。singleTask启动模式默认具有此标记位的效果 三、IntentFilter的匹配规则我们知道，启动Activity分为两种，显示调用和隐式调用。原则上一个Intent不应该即使显示调用又是隐式调用，如果两者共存的话以显示调用为主。显示调用很简单，这里主要介绍隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFileter中所设置的过滤信息，如果不匹配将无法启动目标Activity。IntentFilter中的过滤信息有action、category、data。 action匹配规则action是一个字符串，系统预定义一些action，同事我们也可以在应用中定义自己的action。action匹配规则是intent中的action必须能够和过滤规则中的action匹配，这里所的匹配是指action的字符串值完全一样。一个过滤规则中可以有多个action，那么只要Intent中的action‘能够和过滤规则中的任何一个action相同即可匹配成功。 category的匹配规则category是一个字符串，系统预定义了一些category同时我们也可以自定义自己的category。category的匹配规则和action不同，Intent可以不指定category，如果指定了category，那么不管指定了几个category都必须要在过滤规则中的能找到相应的category。为什么Intent可以不指定category呢？原因是系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上 “android.intent.category.DEFAULT” 这个category，所以为了我们的Activit能够被隐式调用，就必须在intent-filter过滤规则中指定 “android.intent.category.DEFAULT” 这个category。 data的匹配规则data的匹配规则和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data。在介绍data的匹配规则之前，我们需要先了解下data的结构，因为data稍微有点复杂。 data的语法12345678&lt;data android:scheme=\"string\" android:host=\"string\" android:port=\"string\" android:path=\"string\" android:pathPattern=\"string\" android:pathPrefix=\"string\" android:mimeType=\"string\" data由两个部分组成，mimeType和URI。mimeType指媒体类型，比如image/jpeg、video/*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] Scheme:URI的模式，比如http、file、content等，如果URI中没有指定scheme，那么整个URI的其他参数无效，这也意味着URI是无效的 Host：URI的主机名，比如www.baidu.com，如果host没有指定，那么整个URI的其他参数无效，这也意味着URI是无效的 Port：URI中的端口号，比如80，仅当URI中指定scheme和host参数的时候port参数才是有意义的 path、pathPattern和pathPrefix：这三个参数表述路径信息，其中path表示完整的路径信息；pathPattern也表示完整的路径信息，但是它里面可以包含通配符 ‘*‘ ，’*‘ 表示0个或者多个任意字符，需要注意的是，由于正则表达式规范的要求，如果想表达真实字符串，那么 ‘*‘ 要写成 ‘\\\\*‘,’\\‘要写成 ‘\\\\‘；pathPrefix表示路径的前缀信息 data的过滤规则有如下过滤规则 1234&lt;intent-filter&gt; &lt;data android:mimeType=\"image/*\" /&gt; ...&lt;/intent-filter&gt; 这种规则指定了媒体类型为所有类型的图片，那么Intent中的mimeType属性必须为 “image/*”才能匹配，这种情况下过滤规则虽然没有指定URI，但是却有默认值，URI默认值为content何file。也就是说，虽然没有指定URI，但是Intent中的URI部分的scheme必须为content或者file才能匹配。为了匹配上面的过滤规则，我们可以写出如下示例： 1intent.setDataAndType(Uri.parse(\"file://abc\"),\"image/png\"); 另外，如果要为Intent指定完整的data，必须调用setDataAndType方法，不能先调用setData在调用setType，因为这两个方法彼此会清楚对方的值，setData会吧mimeType置为null，同理setType也会把URI置为null 有如下过滤规则 1234&lt;intent-filter&gt; &lt;data android:mimeType=\"video/mpeg\" android:scheme=\"http\" .../&gt; &lt;data android:mimeType=\"audio/mpeg\" android:scheme=\"http\" .../&gt;&lt;/intent-filter&gt; 这种规则指定了两组data规则，且每个data都指定了完整的属性值，既有URI又有mimeType。为了匹配上面的规则，我们可以写出如下示例: 1intent.setDataAndType(Uri.parse(\"http://abc\"),\"video/mpeng\"); 或者 1intent.setDataAndType(Uri.parse(\"http://abc\"),\"audio/mpeng\"); 通过上面示例，读者应该明白了data的匹配规则，关于data还有一个特殊情况需要说明，这也是和action不同的地方，如下两组特殊写法，它们是一样的： 12345678&lt;intent-filter&gt; &lt;data android:scheme=\"file\" android:host=\"www.baidu.com\"/&gt;&lt;/intent-filter&gt;&lt;intent-filter&gt; &lt;data android:scheme=\"file\"/&gt; &lt;data android:host=\"www.baidu.com\" /&gt;&lt;/intent-filter&gt; 最后当我们隐式启动Activity的时候，可以做下判断，看是否有Activity能够匹配我们的隐式Intent，如果不做判断就有可能出现 ActivityNotFoundException。判断有两种：采用PackageManager的resolveActivity或者Intent的resolveActivity方法，如果它们找不到匹配的Activity就会返回null，它们通过判断返回值就可以避免上述异常。另外PackageManager还提供了queryIntentActivity方法，这个方法和resolveActivity方法不同：他不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息","raw":null,"content":null,"categories":null,"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Android 文件存储","slug":null,"date":"2016-02-16T07:21:00.000Z","updated":null,"comments":null,"path":"2016/02/16/2016021615_Android本地存储器/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"本文内容来自Android官方培训文档-保存文件，在此基础上添加了部分内容 所有的Android设备都有2个文件存储区域：”外部” 和 “内部” 存储。这些名称在 Android 早期产生，当时大多数设备都提供内置的非易失性内存（内部存储），以及移动存储介质，比如微型 SD 卡（外部存储）。一些设备将永久性存储空间划分为”内部”和”外部”分区，即便没有移动存储介质，也始终有两个存储空，并且无论外部存储设备是否可移动，API 的行为均一致。以下列表汇总了关于各个存储空间的实际信息。 内部存储 外部存储 始终可用 并非始终可用，因为用户可采用 USB 存储的形式装载外部存储，并在某些情况下会从设备中将其删除 默认情况下只有您的应用可以访问此处保存的文件 它是全局可读的，因此此处保存的文件可能不受您控制地被读取 当用户卸载您的应用时，系统会从内部存储中删除您的应用的所有文件 当用户卸载您的应用时，只有在您通过 getExternalFilesDir() 将您的应用的文件保存在目录中时，系统才会从此处删除您的应用的文件 无需向用户获取存储读写权限 除了在 android 4.4及其之后的版本使用getExternalFilesDir()进行读写操作外，都需要向用户获取存储读写权限 当您希望确保用户或其他应用均无法访问您的文件时，内部存储是最佳选择。 对于无需访问限制以及您希望与其他应用共享或允许用户使用电脑访问的文件，外部存储是最佳位置。 尽管应用默认安装在内部存储中，但您可以在您的manifest文件中指定android:installLocation属性，这样您的应用便可以安装在外部存储中。当APK非常大且它们的外部存储空间大于内部存储时，用户更青睐这个选择。如需了解详细信息，请参阅应用安装位置 一、将文件保存在内部存储中在内部存储中保存文件时，您可以通过调用以下两种方法之一获取作为 File 的相应目录： getFilesDir()) 返回表示您的应用的内部目录的 File getCacheDir()) 返回表示您的应用临时缓存文件的内部目录的 File 。 务必删除所有不再需要的文件并对在指定时间您使用的内存量实现合理大小限制，比如，1MB。 如果在系统即将耗尽存储，它会在不进行警告的情况下删除您的缓存文件。 要在这些目录之一中新建文件，您可以使用 File() 构造函数，传递指定您的内部存储目录的上述方法之一所提供的 File 。例如： 1File file = new File(context.getFilesDir(), filename); 或者，您可以调用 openFileOutput() 获取写入到内部目录中的文件的 FileOutputStream 。例如，此处显示如何向文件写入一些文本： 1234567891011String filename = \"myfile\";String string = \"Hello world!\";FileOutputStream outputStream;try &#123; outputStream = openFileOutput(filename, Context.MODE_PRIVATE); outputStream.write(string.getBytes()); outputStream.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 或者，如果您需要缓存某些文件，您应改用 createTempFile()。例如，以下方法从 URL 提取文件名并在您的应用的内部缓存目录中以该名称创建文件： 12345678910public File getTempFile(Context context, String url) &#123; File file; try &#123; String fileName = Uri.parse(url).getLastPathSegment(); file = File.createTempFile(fileName, null, context.getCacheDir()); catch (IOException e) &#123; // Error while creating file &#125; return file;&#125; 注意： 您的应用的内部存储设备目录由您的应用在Android 文件系统特定位置中的软件包名称指定。在技术上，如果您将文件模式设置为可读，另一个应用可以读取您的内部文件。 但是，另一个应用也需要知道您的应用的软件包名称和文件名。 其他应用无法浏览您的内部目录并且没有读写权限，除非您明确将文件设置为可读或可写。 只要您为内部存储上的文件使用 MODE_PRIVATE， 其他应用便不能访问它们。 二、将文件保存在外部存储中由于外部存储可能不可用—比如，当用户已将存储装载到电脑或已移除提供外部存储的 SD 卡时—因此，在访问它之前，您应始终确认其容量。 您可以通过调用 getExternalStorageState() 查询外部存储状态。 如果返回的状态为 MEDIA_MOUNTED，那么您可以对您的文件进行读写。 例如，以下方法对于确定存储可用性非常有用： 123456789101112131415161718/* 检查这个外部存储器是否可用的并且是否可读可写的 */public boolean isExternalStorageWritable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) &#123; return true; &#125; return false;&#125;/* 检查这个外部存储器是否可用并且是否可读 */public boolean isExternalStorageReadable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; return true; &#125; return false;&#125; 尽管外部存储可被用户和其他应用进行修改，但您可在此处保存两类文件： 公共文件 应供其他应用和用户自由使用的文件。 当用户卸载您的应用时，用户应仍可以使用这些文件。 例如，您的应用拍摄的照片或其他已下载的文件。 私有文件 属于您的应用且应在用户卸载您的应用时删除的文件。尽管这些文件在技术上可被用户和其他应用访问（因为它们在外部存储上），它们是实际上不向您的应用之外的用户提供内容的文件。当用户卸载您的应用时，系统会删除应用专用目录中的所有文件。 例如，您的应用下载的其他资源或临时介质文件。 获取外部存储的权限要向外部存储写入信息，您必须在您的宣示说明文件中请求 WRITE_EXTERNAL_STORAGE 权限。 1234&lt;manifest ...&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; ...&lt;/manifest&gt; 需要注意的是在 android6.0 以上存储权限属于运行时权限，如果app的targetSdkVersion 低于 23，那将被继续使用旧有规则，安装后app就有了那些权限，app可以向以往一样运行，但是用户依然可以取消已经同意的授权，这时如果调用了需要权限的函数那么就有可能会抛出异常了。因此在 6.0 以上版本中我们需要做额外的判断，来适应新的规则 123456789private void insertDummyContactWrapper() &#123; int hasPermission = checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE); if (hasPermission != PackageManager.PERMISSION_GRANTED) &#123; requestPermissions(new String[] &#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, REQUEST_CODE_ASK_PERMISSIONS); return; &#125; ...&#125; 通过checkSelfPermission判断是否已经获取权限，如果没有获取requestPermissions被执行来弹出请求授权对话框。 最后不管用户是拒绝还是同意activity的回调方法onRequestPermissionsResult都会被执行来通知结果 1234567891011121314151617@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case REQUEST_CODE_ASK_PERMISSIONS: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // 授予权限 ... &#125; else &#123; // 拒绝权限 Toast.makeText(MainActivity.this, \"WRITE_EXTERNAL_STORAGE Denied\", Toast.LENGTH_SHORT) .show(); &#125; break; default: super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125;&#125; 更多内容请看 Android M 新的运行时权限开发者需要知道的一切 注意： 目前，所有应用都可以读取外部存储，而无需特别的权限。 但这在将来版本中会进行更改。如果您的应用需要读取外部存储（但不向其写入信息），那么您将需要声明 READ_EXTERNAL_STORAGE 权限。 但是，如果您的应用使用 WRITE_EXTERNAL_STORAGE 权限，那么它也隐含读取外部存储的权限。您无需任何权限，即可在内部存储中保存文件。 您的应用始终具有在其内部存储目录中进行读写的权限。 公共文件读写如果您要使用外部存储上的公共文件，请使用 getExternalStoragePublicDirectory() 方法获取表示外部存储上相应目录的 File 。该方法使用指定 您想要保存以便它们可以与其他公共文件在逻辑上组织在一起的文件类型的参数，比如 DIRECTORY_MUSIC 或 DIRECTORY_PICTURES。 例如： 123456789public File getAlbumStorageDir(String albumName) &#123; // Get the directory for the user's public pictures directory. File file = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, \"Directory not created\"); &#125; return file;&#125; 私有文件读写如果您要保存您的应用专用文件，您可以通过调用 getExternalFilesDir() 获取相应的目录并向其传递指示您想要的目录类型的名称。 通过这种方法创建的各个目录将添加至封装您的应用的所有外部存储文件的父目录，当用户卸载您的应用时，系统会删除这些文件。 例如，您可以使用以下方法来创建个人相册的目录： 123456789public File getAlbumStorageDir(Context context, String albumName) &#123; // Get the directory for the app's private pictures directory. File file = new File(context.getExternalFilesDir( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, \"Directory not created\"); &#125; return file;&#125; 如果没有适合您文件的预定义子目录名称，您可以改为调用 getExternalFilesDir() 并传递 null。这将返回外部存储上您的应用的专用目录 的根目录。 切记，getExternalFilesDir() 在用户卸载您的应用时删除的目录内创建目录。如果您正保存的文件应在用户卸载您的应用后仍然可用—比如，当您的应用是照相机并且用户要保留照片时—您应改用 getExternalStoragePublicDirectory()。 无论您对于共享的文件使用 getExternalStoragePublicDirectory() 还是对您的应用专用文件使用 getExternalFilesDir() ，您使用诸如 DIRECTORY_PICTURES 的 API 常数提供的目录名称非常重要。 这些目录名称可确保系统正确处理文件。 例如，保存在 DIRECTORY_RINGTONES 中的文件由系统介质扫描程序归类为铃声，而不是音乐。 三、查询可用空间如果您事先知道您将保存的数据量，可以通过执行getFreeSpace() 和 getTotalSpace() 来判断是否有足够的空间来保存文件，从而避免发生IOException。 这些方法分别提供目前的可用空间和存储卷中的总空间。 此信息也可用来避免填充存储卷以致超出特定阈值。 但是，系统并不保证您可以写入与 getFreeSpace() 指示的一样多的字节。如果返回的数字比您要保存的数据大小大出几 MB，或如果文件占剩余空间不到 90%，则可安全继续操作。否则，不要写入存储。 四、删除文件在不需要使用某些文件的时候应删除它。删除文件最直接的方法是直接执行文件的delete()方法。 1myFile.delete(); 如果文件是保存在internal storage，我们可以通过Context来访问并通过执行deleteFile()进行删除 1myContext.deleteFile(fileName); 当用户卸载您的应用时，Android 系统会删除以下各项： 您保存在内部存储中的所有文件 您使用 getExternalFilesDir() 保存在外部存储中的所有文件。 但是，您应定期手动删除使用 getCacheDir() 创建的所有缓存文件以及删除不再需要的其他文件。","raw":null,"content":null,"categories":null,"tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Android Studio 全文搜索","slug":null,"date":"2016-02-16T06:05:00.000Z","updated":null,"comments":null,"path":"2016/02/16/2016021614_AndroidStudio全文查找/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"全文搜索是一个很好用的功能，在mac上全文搜索的快捷键为cmd + shift + R 可选择的搜索属性如下图所示 上图中的Context除了anywhere之外还有多个选项 英 中 anywhere 任何地方查找 in comments 在注释中查找 in string literals 在字符串中查找 except comments 除了注释（注释之外查找） except string literals 除了字符串 (在字符串之外查找) except comments and string literals 除了注释和字符串(在注释和字符串之外查找)","raw":null,"content":null,"categories":null,"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://yoursite.com/tags/Android-Studio/"}]},{"title":"Android仿淘宝闲鱼底部TabBar","slug":null,"date":"2015-12-18T03:15:00.000Z","updated":null,"comments":null,"path":"2015/12/18/2015121811_Android仿淘宝闲鱼/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"由于ios的底部tabbar在国内的流行，很多时候android端也不得不采用底部tabbar，但是这简单的tabbar也被很多人玩出了新花样，其一便是如闲鱼app里中间一个按钮凸起的样子。 如图所示的Tabbar其实是由2个LinearLayout组成 第一个LinearLayout为横向，包含5个竖向的LinearLayout，竖向LinearLayout里面就是用于设置图片和文字的ImageView和TextView，其中第三个LinearLayout也就是中间的发布所在LinearLayout只设置了文字没有设置图片 第二个LinearLayout更加简单，只包含了一个ImageView，也就是图片中凸起的按钮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--主内容显示区域 --&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_above=\"@+id/mainTabBar\"/&gt; &lt;!--阴影分割线 --&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/mainTabBar\" android:background=\"@mipmap/comui_bar_top_shadow\"/&gt; &lt;!--第一个LinearLayout 内有5个竖向LinearLayout--&gt; &lt;LinearLayout android:id=\"@+id/mainTabBar\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:layout_alignParentBottom=\"true\" android:orientation=\"horizontal\"&gt; &lt;... /&gt; &lt;/LinearLayout&gt; &lt;!--第二个LinearLayout 内有凸起按钮--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"76.0dip\" android:layout_alignParentBottom=\"true\" android:background=\"@android:color/transparent\" android:gravity=\"center|top\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/tab_post_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"onClickPublish\" android:src=\"@mipmap/comui_tab_post\"/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 第一个LinearLayout内应该有5个竖向的LinearLayout，因为是重复代码所以只贴出其中一个 1234567891011121314151617181920212223242526&lt;LinearLayout android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/tab_icon\" android:layout_width=\"24.0dip\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:src=\"@mipmap/comui_tab_home\" android:scaleType=\"centerInside\"/&gt; &lt;TextView android:id=\"@+id/tab_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"4dip\" android:textColor=\"#ff333333\" android:text=\"首页\" android:textSize=\"9.0sp\"/&gt;&lt;/LinearLayout&gt; 其余的便是常规的页卡切换操作了。","raw":null,"content":null,"categories":null,"tags":[{"name":"Android UI","slug":"Android-UI","permalink":"http://yoursite.com/tags/Android-UI/"}]}]