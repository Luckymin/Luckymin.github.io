<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android 文件存储 | Min blog | Thought is already is late, exactly is the earliest time.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Android基础">
  <meta name="description" content="本文内容来自Android官方培训文档-保存文件，在此基础上添加了部分内容
所有的Android设备都有2个文件存储区域：”外部” 和 “内部” 存储。这些名称在 Android 早期产生，当时大多数设备都提供内置的非易失性内存（内部存储），以及移动存储介质，比如微型 SD 卡（外部存储）。一些设备将永久性存储空间划分为”内部”和”外部”分区，即便没有移动存储介质，也始终有两个存储空，并且无论外部">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 文件存储">
<meta property="og:url" content="http://yoursite.com/2016/02/16/2016021615_Android本地存储器/index.html">
<meta property="og:site_name" content="Min blog">
<meta property="og:description" content="本文内容来自Android官方培训文档-保存文件，在此基础上添加了部分内容
所有的Android设备都有2个文件存储区域：”外部” 和 “内部” 存储。这些名称在 Android 早期产生，当时大多数设备都提供内置的非易失性内存（内部存储），以及移动存储介质，比如微型 SD 卡（外部存储）。一些设备将永久性存储空间划分为”内部”和”外部”分区，即便没有移动存储介质，也始终有两个存储空，并且无论外部">
<meta property="og:updated_time" content="2016-03-02T06:59:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 文件存储">
<meta name="twitter:description" content="本文内容来自Android官方培训文档-保存文件，在此基础上添加了部分内容
所有的Android设备都有2个文件存储区域：”外部” 和 “内部” 存储。这些名称在 Android 早期产生，当时大多数设备都提供内置的非易失性内存（内部存储），以及移动存储介质，比如微型 SD 卡（外部存储）。一些设备将永久性存储空间划分为”内部”和”外部”分区，即便没有移动存储介质，也始终有两个存储空，并且无论外部">
  
    <link rel="alternative" href="/atom.xml" title="Min blog" type="application/atom+xml">
  
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner">
  <a href="javascript:;" class="header-icon waves-circle-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="./" class="avatar"><img src="/img/logo.png"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Luckymin</h5>
        <a href="mailto:undefined" title="kluckymin@gmail.com" class="mail">kluckymin@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav">
    
        <li class="waves-block">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>Home
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>Archives
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>Tags
          </a>
        </li>
    
        <li class="waves-block">
          <a href="https://github.com/Luckymin" target="_blank" >
            <i class="icon icon-lg icon-github"></i>Github
          </a>
        </li>
    
        <li class="waves-block">
          <a href="http://weibo.com/staringmake" target="_blank" >
            <i class="icon icon-lg icon-weibo"></i>Weibo
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>Min blog &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-circle-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android 文件存储</div>
        <a href="javascript:;" class="header-icon waves-circle-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Android 文件存储</h1>
    <h5 class="subtitle">2016-02-16</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <article id="post-2016021615_Android本地存储器" class="article article-type-post" itemscope itemprop="blogPost">
    
      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android基础/">Android基础</a></li></ul>
</div>
      </div>
      <div class="post-body">

        <aside class="post-widget" id="post-widget">

          
          <div class="post-share" id="post-share" data-title="Android 文件存储" data-pic="/img/logo.png" data-summary="&lt;p&gt;&lt;strong&gt;本文内容来自&lt;a href=&quot;http://developer.android.com/intl/zh-cn/training/basics/data-storage/files.html&quot;&gt;Android官方培训文档-保存文件&lt;/a&gt;，在此基础上添加了部分内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的Android设备都有2个文件存储区域：”外部” 和 “内部” 存储。这些名称在 Android 早期产生，当时大多数设备都提供内置的非易失性内存（内部存储），以及移动存储介质，比如微型 SD 卡（外部存储）。一些设备将永久性存储空间划分为”内部”和”外部”分区，即便没有移动存储介质，也始终有两个存储空，并且无论外部存储设备是否可移动，API 的行为均一致。以下列表汇总了关于各个存储空间的实际信息。&lt;/p&gt;" data-url="http://yoursite.com/2016/02/16/2016021615_Android本地存储器/index.html">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

          

          
          <nav class="post-toc-wrap" id="post-toc">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#u4E00_u3001_u5C06_u6587_u4EF6_u4FDD_u5B58_u5728_u5185_u90E8_u5B58_u50A8_u4E2D"><span class="post-toc-text">一、将文件保存在内部存储中</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#u4E8C_u3001_u5C06_u6587_u4EF6_u4FDD_u5B58_u5728_u5916_u90E8_u5B58_u50A8_u4E2D"><span class="post-toc-text">二、将文件保存在外部存储中</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#u83B7_u53D6_u5916_u90E8_u5B58_u50A8_u7684_u6743_u9650"><span class="post-toc-text">获取外部存储的权限</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#u516C_u5171_u6587_u4EF6_u8BFB_u5199"><span class="post-toc-text">公共文件读写</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#u79C1_u6709_u6587_u4EF6_u8BFB_u5199"><span class="post-toc-text">私有文件读写</span></a></li></ol></li></ol>
          </nav>
          
        </aside>

        <div class="post-main">

            <div class="post-content" itemprop="postContent"><p><strong>本文内容来自<a href="http://developer.android.com/intl/zh-cn/training/basics/data-storage/files.html" target="_blank" rel="external">Android官方培训文档-保存文件</a>，在此基础上添加了部分内容</strong></p>
<p>所有的Android设备都有2个文件存储区域：”外部” 和 “内部” 存储。这些名称在 Android 早期产生，当时大多数设备都提供内置的非易失性内存（内部存储），以及移动存储介质，比如微型 SD 卡（外部存储）。一些设备将永久性存储空间划分为”内部”和”外部”分区，即便没有移动存储介质，也始终有两个存储空，并且无论外部存储设备是否可移动，API 的行为均一致。以下列表汇总了关于各个存储空间的实际信息。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>内部存储</th>
<th>外部存储</th>
</tr>
</thead>
<tbody>
<tr>
<td>始终可用</td>
<td>并非始终可用，因为用户可采用 USB 存储的形式装载外部存储，并在某些情况下会从设备中将其删除</td>
</tr>
<tr>
<td>默认情况下只有您的应用可以访问此处保存的文件</td>
<td>它是全局可读的，因此此处保存的文件可能不受您控制地被读取</td>
</tr>
<tr>
<td>当用户卸载您的应用时，系统会从内部存储中删除您的应用的所有文件</td>
<td>当用户卸载您的应用时，只有在您通过 getExternalFilesDir() 将您的应用的文件保存在目录中时，系统才会从此处删除您的应用的文件</td>
</tr>
<tr>
<td>无需向用户获取存储读写权限</td>
<td>除了在 android 4.4及其之后的版本使用getExternalFilesDir()进行读写操作外，都需要向用户获取存储读写权限</td>
</tr>
<tr>
<td>当您希望确保用户或其他应用均无法访问您的文件时，内部存储是最佳选择。</td>
<td>对于无需访问限制以及您希望与其他应用共享或允许用户使用电脑访问的文件，外部存储是最佳位置。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>尽管应用默认安装在内部存储中，但您可以在您的manifest文件中指定android:installLocation属性，这样您的应用便可以安装在外部存储中。当APK非常大且它们的外部存储空间大于内部存储时，用户更青睐这个选择。如需了解详细信息，请参阅<a href="http://developer.android.com/intl/zh-cn/guide/topics/data/install-location.html" target="_blank" rel="external">应用安装位置</a></p>
</blockquote>
<h2 id="u4E00_u3001_u5C06_u6587_u4EF6_u4FDD_u5B58_u5728_u5185_u90E8_u5B58_u50A8_u4E2D"><a href="#u4E00_u3001_u5C06_u6587_u4EF6_u4FDD_u5B58_u5728_u5185_u90E8_u5B58_u50A8_u4E2D" class="headerlink" title="一、将文件保存在内部存储中"></a>一、将文件保存在内部存储中</h2><p>在内部存储中保存文件时，您可以通过调用以下两种方法之一获取作为 File 的相应目录：</p>
<ul>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Context.html#getFilesDir(" target="_blank" rel="external">getFilesDir()</a>)  返回表示您的应用的内部目录的 File </li>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/content/Context.html#getCacheDir(" target="_blank" rel="external">getCacheDir()</a>)  返回表示您的应用临时缓存文件的内部目录的 File 。 务必删除所有不再需要的文件并对在指定时间您使用的内存量实现合理大小限制，比如，1MB。 如果在系统即将耗尽存储，它会在不进行警告的情况下删除您的缓存文件。</li>
</ul>
<p>要在这些目录之一中新建文件，您可以使用 File() 构造函数，传递指定您的内部存储目录的上述方法之一所提供的 File 。例如：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="keyword">context</span>.getFilesDir(), filename);</span><br></pre></td></tr></table></figure>
<p>或者，您可以调用 openFileOutput() 获取写入到内部目录中的文件的 <a href="http://developer.android.com/intl/zh-cn/reference/java/io/FileOutputStream.html" target="_blank" rel="external">FileOutputStream</a> 。例如，此处显示如何向文件写入一些文本：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">filename</span> = <span class="string">"myfile"</span>;</span><br><span class="line">String <span class="keyword">string</span> = <span class="string">"Hello world!"</span>;</span><br><span class="line">FileOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  outputStream = openFileOutput(<span class="keyword">filename</span>, Context.MODE_PRIVATE);</span><br><span class="line">  outputStream.write(<span class="keyword">string</span>.getBytes());</span><br><span class="line">  outputStream.<span class="keyword">close</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，如果您需要缓存某些文件，您应改用 createTempFile()。例如，以下方法从 URL 提取文件名并在您的应用的内部缓存目录中以该名称创建文件：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">File</span> getTempFile(Context context, String url) &#123;</span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String fileName = Uri.parse(url).getLastPathSegment();</span><br><span class="line">        <span class="keyword">file</span> = <span class="keyword">File</span>.createTempFile(fileName, <span class="keyword">null</span>, context.getCacheDir());</span><br><span class="line">    <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Error while creating file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">file</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 您的应用的内部存储设备目录由您的应用在Android 文件系统特定位置中的软件包名称指定。在技术上，如果您将文件模式设置为可读，另一个应用可以读取您的内部文件。 但是，另一个应用也需要知道您的应用的软件包名称和文件名。 其他应用无法浏览您的内部目录并且没有读写权限，除非您明确将文件设置为可读或可写。 只要您为内部存储上的文件使用 MODE_PRIVATE， 其他应用便不能访问它们。</p>
</blockquote>
<h2 id="u4E8C_u3001_u5C06_u6587_u4EF6_u4FDD_u5B58_u5728_u5916_u90E8_u5B58_u50A8_u4E2D"><a href="#u4E8C_u3001_u5C06_u6587_u4EF6_u4FDD_u5B58_u5728_u5916_u90E8_u5B58_u50A8_u4E2D" class="headerlink" title="二、将文件保存在外部存储中"></a>二、将文件保存在外部存储中</h2><p>由于外部存储可能不可用—比如，当用户已将存储装载到电脑或已移除提供外部存储的 SD 卡时—因此，在访问它之前，您应始终确认其容量。 您可以通过调用 getExternalStorageState() 查询外部存储状态。 如果返回的状态为 MEDIA_MOUNTED，那么您可以对您的文件进行读写。 例如，以下方法对于确定存储可用性非常有用：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 检查这个外部存储器是否可用的并且是否可读可写的 */</span><br><span class="line">public boolean isExternalStorageWritable() &#123;</span><br><span class="line">    String <span class="keyword">state</span> = Environment.getExternalStorageState();</span><br><span class="line">    if (Environment.MEDIA_MOUNTED.equals(<span class="keyword">state</span>)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 检查这个外部存储器是否可用并且是否可读 */</span><br><span class="line">public boolean isExternalStorageReadable() &#123;</span><br><span class="line">    String <span class="keyword">state</span> = Environment.getExternalStorageState();</span><br><span class="line">    if (Environment.MEDIA_MOUNTED.equals(<span class="keyword">state</span>) ||</span><br><span class="line">        Environment.MEDIA_MOUNTED_READ_ONLY.equals(<span class="keyword">state</span>)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管外部存储可被用户和其他应用进行修改，但您可在此处保存两类文件：</p>
<ul>
<li><p>公共文件</p>
<p>   应供其他应用和用户自由使用的文件。 当用户卸载您的应用时，用户应仍可以使用这些文件。</p>
<p>  例如，您的应用拍摄的照片或其他已下载的文件。</p>
</li>
<li><p>私有文件</p>
<p>  属于您的应用且应在用户卸载您的应用时删除的文件。尽管这些文件在技术上可被用户和其他应用访问（因为它们在外部存储上），它们是实际上不向您的应用之外的用户提供内容的文件。当用户卸载您的应用时，系统会删除应用专用目录中的所有文件。</p>
<p>  例如，您的应用下载的其他资源或临时介质文件。</p>
</li>
</ul>
<h3 id="u83B7_u53D6_u5916_u90E8_u5B58_u50A8_u7684_u6743_u9650"><a href="#u83B7_u53D6_u5916_u90E8_u5B58_u50A8_u7684_u6743_u9650" class="headerlink" title="获取外部存储的权限"></a>获取外部存储的权限</h3><p>要向外部存储写入信息，您必须在您的宣示说明文件中请求 WRITE_EXTERNAL_STORAGE 权限。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是在 android6.0 以上存储权限属于运行时权限，如果app的targetSdkVersion 低于 23，那将被继续使用旧有规则，安装后app就有了那些权限，app可以向以往一样运行，但是用户依然可以取消已经同意的授权，这时如果调用了需要权限的函数那么就有可能会抛出异常了。因此在 6.0 以上版本中我们需要做额外的判断，来适应新的规则</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">insertDummyContactWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hasPermission = checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE);</span><br><span class="line">    <span class="keyword">if</span> (hasPermission != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        requestPermissions(<span class="keyword">new</span> String[] &#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;,</span><br><span class="line">                    REQUEST_CODE_ASK_PERMISSIONS);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过checkSelfPermission判断是否已经获取权限，如果没有获取requestPermissions被执行来弹出请求授权对话框。</p>
<p>最后不管用户是拒绝还是同意activity的回调方法onRequestPermissionsResult都会被执行来通知结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, String[] permissions, <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">		<span class="keyword">case</span> REQUEST_CODE_ASK_PERMISSIONS:</span><br><span class="line">            <span class="keyword">if</span> (grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// 授予权限</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 拒绝权限</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"WRITE_EXTERNAL_STORAGE Denied"</span>, Toast.LENGTH_SHORT)</span><br><span class="line">                        .show();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多内容请看 <a href="http://gold.xitu.io/entry/55e2fa1a00b075a5f29a261c" target="_blank" rel="external">Android M 新的运行时权限开发者需要知道的一切</a></p>
<blockquote>
<p>注意： 目前，所有应用都可以读取外部存储，而无需特别的权限。 但这在将来版本中会进行更改。如果您的应用需要读取外部存储（但不向其写入信息），那么您将需要声明 READ_EXTERNAL_STORAGE 权限。</p>
<p>但是，如果您的应用使用 WRITE_EXTERNAL_STORAGE 权限，那么它也隐含读取外部存储的权限。您无需任何权限，即可在内部存储中保存文件。 您的应用始终具有在其内部存储目录中进行读写的权限。</p>
</blockquote>
<h3 id="u516C_u5171_u6587_u4EF6_u8BFB_u5199"><a href="#u516C_u5171_u6587_u4EF6_u8BFB_u5199" class="headerlink" title="公共文件读写"></a>公共文件读写</h3><p>如果您要使用外部存储上的公共文件，请使用 getExternalStoragePublicDirectory() 方法获取表示外部存储上相应目录的 File 。该方法使用指定 您想要保存以便它们可以与其他公共文件在逻辑上组织在一起的文件类型的参数，比如 DIRECTORY_MUSIC 或 DIRECTORY_PICTURES。 例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">File</span> getAlbumStorageDir(String albumName) &#123;</span><br><span class="line">    <span class="comment">// Get the directory for the user's public pictures directory. </span></span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(Environment.getExternalStoragePublicDirectory(</span><br><span class="line">            Environment.DIRECTORY_PICTURES), albumName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">file</span>.mkdirs()) &#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Directory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">file</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u79C1_u6709_u6587_u4EF6_u8BFB_u5199"><a href="#u79C1_u6709_u6587_u4EF6_u8BFB_u5199" class="headerlink" title="私有文件读写"></a>私有文件读写</h3><p>如果您要保存您的应用专用文件，您可以通过调用 getExternalFilesDir() 获取相应的目录并向其传递指示您想要的目录类型的名称。 通过这种方法创建的各个目录将添加至封装您的应用的所有外部存储文件的父目录，当用户卸载您的应用时，系统会删除这些文件。</p>
<p>例如，您可以使用以下方法来创建个人相册的目录：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">File</span> getAlbumStorageDir(Context context, String albumName) &#123;</span><br><span class="line">    <span class="comment">// Get the directory for the app's private pictures directory. </span></span><br><span class="line">    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(context.getExternalFilesDir(</span><br><span class="line">            Environment.DIRECTORY_PICTURES), albumName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">file</span>.mkdirs()) &#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Directory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">file</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果没有适合您文件的预定义子目录名称，您可以改为调用 getExternalFilesDir() 并传递 <span class="keyword">null</span>。这将返回外部存储上您的应用的专用目录 的根目录。</span><br><span class="line"></span><br><span class="line">切记，getExternalFilesDir() 在用户卸载您的应用时删除的目录内创建目录。如果您正保存的文件应在用户卸载您的应用后仍然可用—比如，当您的应用是照相机并且用户要保留照片时—您应改用 getExternalStoragePublicDirectory()。</span><br><span class="line"></span><br><span class="line">无论您对于共享的文件使用 getExternalStoragePublicDirectory() 还是对您的应用专用文件使用 getExternalFilesDir() ，您使用诸如 DIRECTORY_PICTURES 的 API 常数提供的目录名称非常重要。 这些目录名称可确保系统正确处理文件。 例如，保存在 DIRECTORY_RINGTONES 中的文件由系统介质扫描程序归类为铃声，而不是音乐。</span><br><span class="line"></span><br><span class="line">## 三、查询可用空间</span><br><span class="line">如果您事先知道您将保存的数据量，可以通过执行getFreeSpace() 和 getTotalSpace() 来判断是否有足够的空间来保存文件，从而避免发生IOException。 这些方法分别提供目前的可用空间和存储卷中的总空间。 此信息也可用来避免填充存储卷以致超出特定阈值。</span><br><span class="line"></span><br><span class="line">但是，系统并不保证您可以写入与 getFreeSpace() 指示的一样多的字节。如果返回的数字比您要保存的数据大小大出几 MB，或如果文件占剩余空间不到 <span class="number">90</span>%，则可安全继续操作。否则，不要写入存储。</span><br><span class="line"></span><br><span class="line">## 四、删除文件</span><br><span class="line">在不需要使用某些文件的时候应删除它。删除文件最直接的方法是直接执行文件的<span class="keyword">delete</span>()方法。</span><br></pre></td></tr></table></figure>
<p>myFile.delete();<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果文件是保存在internal storage，我们可以通过Context来访问并通过执行<span class="function"><span class="title">deleteFile</span><span class="params">()</span></span>进行删除</span><br></pre></td></tr></table></figure></p>
<p>myContext.deleteFile(fileName);<br>```</p>
<blockquote>
<p>当用户卸载您的应用时，Android 系统会删除以下各项：</p>
<ul>
<li>您保存在内部存储中的所有文件</li>
<li>您使用 getExternalFilesDir() 保存在外部存储中的所有文件。</li>
</ul>
<p>但是，您应定期手动删除使用 getCacheDir() 创建的所有缓存文件以及删除不再需要的其他文件。</p>
</blockquote>
</div>

            
<nav class="post-nav flex-row">
  <div class="flex-col waves-block prev">
    
      <a href="/2016/02/27/2016022717_Activity的启动模式和匹配规则/" title="Activity的启动模式和匹配规则" id="post-prev" class="post-nav-link">
        <i class="icon icon-chevron-left"></i>
        <span class="article-nav-title">上一篇</span>
      </a>
    
  </div>
  <div class="flex-col waves-block next">
    
      <a href="/2016/02/16/2016021614_AndroidStudio全文查找/" title="Android Studio 全文搜索" id="post-next" class="post-nav-link">
        <span class="article-nav-title">下一篇</span>
        <i class="icon icon-chevron-right"></i>
      </a>
    
  </div>

</nav>



            




        </div>

      </div>

    

  </article>



    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-circle-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<div class="global-share" id="global-share" data-title="Android 文件存储" data-pic="/img/logo.png" data-summary="&lt;p&gt;&lt;strong&gt;本文内容来自&lt;a href=&quot;http://developer.android.com/intl/zh-cn/training/basics/data-storage/files.html&quot;&gt;Android官方培训文档-保存文件&lt;/a&gt;，在此基础上添加了部分内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的Android设备都有2个文件存储区域：”外部” 和 “内部” 存储。这些名称在 Android 早期产生，当时大多数设备都提供内置的非易失性内存（内部存储），以及移动存储介质，比如微型 SD 卡（外部存储）。一些设备将永久性存储空间划分为”内部”和”外部”分区，即便没有移动存储介质，也始终有两个存储空，并且无论外部存储设备是否可移动，API 的行为均一致。以下列表汇总了关于各个存储空间的实际信息。&lt;/p&gt;" data-url="http://yoursite.com/2016/02/16/2016021615_Android本地存储器/index.html">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js" type="text/javascript"></script>




<script type="text/javascript">
var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1257735577' style='display:none' %3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1257735577%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
</script>






</body>
</html>
